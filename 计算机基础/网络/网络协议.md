### 网络分层的真实含义是什么？
当你听到什么**二层设备、三层设备、四层 LB 和七层 LB** 中层的时候，是否有点一头雾水，不知道这些所谓的层，对应的各种协议具体要做什么工作?

#### 网络为什么要分层？
一般复杂的程序都要分层，这是程序设计的要求

复杂的电商会分数据库层、缓存层、Compose 层、Controller 层和接入层，每一层专注做本层的事情

#### 程序是如何工作的？

![网络程序工作流程](./img/网络程序工作流程.PNG "网络程序工作流程")

当一个网络包从一个网口经过的时候，你看到了，首先先看看要不要请进来，处理一把。有的网口配置了混杂模式，凡是经过的，全部拿进来

拿进来以后，就要交给一段程序来处理。于是，你调用 `process_layer2(buffer)`。当然，这是一个假的函数。但是你明白其中的意思，知道肯定是有这么个函数的。那这个函数是干什么的呢？从 `Buffer` 中，摘掉二层的头，看一看，应该根据头里面的内容做什么操作

假设你发现这个包的 `MAC` 地址和你的相符，那说明就是发给你的，于是需要调用 `process_layer3(buffer)`。这个时候，`Buffer` 里面往往就没有二层的头了，因为已经在上一个函数的处理过程中拿掉了，或者将开始的偏移量移动了一下。在这个函数里面，摘掉三层的头，看看到底是发送给自己的，还是希望自己转发出去的

如何判断呢？如果 `IP` 地址不是自己的，那就应该转发出去；如果 `IP` 地址是自己的，那就是发给自己的。根据 `IP` 头里面的标示，拿掉三层的头，进行下一层的处理，到底是调用 `process_tcp(buffer)` 呢，还是调用 `process_udp(buffer)` 呢？

假设这个地址是 `TCP` 的，则会调用 `process_tcp(buffer)`。这时候，`Buffer` 里面没有三层的头，就需要查看四层的头，看这是一个发起，还是一个应答，又或者是一个正常的数据包，然后分别由不同的逻辑进行处理。如果是发起或者应答，接下来可能要发送一个回复包；如果是一个正常的数据包，就需要交给上层了。交给谁呢？是不是有 `process_http(buffer)` 函数呢？

没有的，如果你是一个网络包处理程序，你不需要有 `process_http(buffer)`，而是应该交给应用去处理。交给哪个应用呢？在四层的头里面有端口号，不同的应用监听不同的端口号。如果发现浏览器应用在监听这个端口，那你发给浏览器就行了。至于浏览器怎么处理，和你没有关系

浏览器自然是解析 `HTML`，显示出页面来。电脑的主人看到页面很开心，就点了鼠标。点击鼠标的动作被浏览器捕获。浏览器知道，又要发起另一个 `HTTP` 请求了，于是使用端口号，将请求发给了你

你应该调用 `send_tcp(buffer)`。不用说，`Buffer` 里面就是 `HTTP` 请求的内容。这个函数里面加一个 `TCP` 的头，记录下源端口号。浏览器会给你目的端口号，一般为 `80` 端口

然后调用 `send_layer3(buffer)`。`Buffer` 里面已经有了 `HTTP` 的头和内容，以及 `TCP` 的头。在这个函数里面加一个 `IP` 的头，记录下源 `IP` 的地址和目标 `IP` 的地址

然后调用 `send_layer2(buffer)`。`Buffer` 里面已经有了 `HTTP` 的头和内容、`TCP` 的头，以及 `IP` 的头。这个函数里面要加一下 `MAC` 的头，记录下源 `MAC` 地址，得到的就是本机器的 `MAC` 地址和目标的 `MAC` 地址。不过，这个还要看当前知道不知道，知道就直接加上；不知道的话，就要通过一定的协议处理过程，找到 `MAC` 地址。反正要填一个，不能空着

万事俱备，只要 `Buffer` 里面的内容完整，就可以从网口发出去了，你作为一个程序的任务就算告一段落了

#### 揭秘层与层之间的关系

网络分层比喻：**现实生活中，往往是员工说一句，组长补充两句，然后经理补充两句，最后总经理再补充两句。但是在网络世界，应该是总经理说话，经理补充两句，组长补充两句，员工再补充两句**

那 TCP 在三次握手的时候，IP 层和 MAC 层在做什么呢？当然是 TCP 发送每一个消息，都会带着 IP 层和 MAC 层了。因为，TCP 每发送一个消息，IP 层和 MAC 层的所有机制都要运行一遍

这里要记住一点：**只要是在网络上跑的包，都是完整的。可以有下层没上层，绝对不可能有上层没下层**

所以，对 TCP 协议来说，三次握手也好，重试也好，只要想发出去包，就要有 IP 层和 MAC 层，不然是发不出去的

经常有人会问这样一个问题，我都知道那台机器的 IP 地址了，直接发给他消息呗，要 MAC 地址干啥？这里的关键就是，没有 MAC 地址消息是发不出去的

所以如果一个 HTTP 协议的包跑在网络上，它一定是完整的。无论这个包经过哪些设备，它都是完整的

**所谓的二层设备、三层设备，都是这些设备上跑的程序不同而已。一个 HTTP 协议的包经过一个二层设备，二层设备收进去的是整个网络包。这里面 HTTP、TCP、 IP、 MAC 都有。什么叫二层设备呀，就是只把 MAC 头摘下来，看看到底是丢弃、转发，还是自己留着。那什么叫三层设备呢？就是把 MAC 头摘下来之后，再把 IP 头摘下来，看看到底是丢弃、转发，还是自己留着**

#### 阶段小结
- 始终想象自己是一个处理网络包的程序：如何拿到网络包，如何根据规则进行处理，如何发出去；
- 始终牢记一个原则：只要是在网络上跑的包，都是完整的。可以有下层没上层，绝对不可能有上层没下层


### 查看ip地址
大部分的网卡都会有一个 IP 地址, **IP 地址是一个网卡在网络世界的通讯地址，相当于我们现实世界的门牌号码**

IP 地址不能大家都一样，不然就会起冲突, 有时候咱们的电脑弹出网络地址冲突，出现上不去网的情况，多半是 IP 地址冲突了

`10.100.122.2` 就是一个 IP 地址。这个地址被点分隔为四个部分，每个部分 `8 个 bit`，所以 IP 地址总共是 `32` 位。这样产生的 IP 地址的数量很快就不够用了。因为当时设计 IP 地址的时候，哪知道今天会有这么多的计算机啊！因为不够用，于是就有了 `IPv6`， `fe80::f816:3eff:fec7:7975/64`。这个有 `128` 位，现在看来是够了，但是未来的事情谁知道呢？

本来 32 位的 IP 地址就不够，还被分成了 5 类:

![ip地址分类](./img/IP地址分类.PNG "ip地址分类")

在网络地址中，至少在当时设计的时候，对于 A、B、 C 类主要分两部分，前面一部分是**网络号**，后面一部分是**主机号**。这很好理解，大家都是六单元 1001 号，我是小区 A 的六单元 1001 号，而你是小区 B 的六单元 1001 号

A、B、C 三类地址所能包含的主机的数量:

![](./img/ABC主机数量.PNG "")

这里面有个尴尬的事情，就是 C 类地址能包含的最大主机数量实在太少了，只有 254 个。当时设计的时候恐怕没想到，现在估计一个网吧都不够用吧。而 B 类地址能包含的最大主机数量又太多了。6 万多台机器放在一个网络下面，一般的企业基本达不到这个规模，闲着的地址就是浪费

#### 无类型域间选路（CIDR）

**CIDR**这种方式打破了原来设计的几类地址的做法，将 32 位的 IP 地址一分为二，前面是**网络号**，后面是**主机号**。从哪里分呢？你如果注意观察的话可以看到，`10.100.122.2/24`，这个 IP 地址中有一个**斜杠**，斜杠后面有个数字 `24`。这种地址表示形式，就是 **CIDR**。后面 24 的意思是，32 位中，**前 24 位是网络号，后 8 位是主机号**


伴随着 **CIDR** 存在的，一个是**广播地址**，`10.100.122.255`。如果发送这个地址，所有 `10.100.122` 网络里面的机器都可以收到。另一个是**子网掩码**，`255.255.255.0`


**将子网掩码和 IP 地址进行 AND 计算。前面三个 255，转成二进制都是 1。1 和任何数值取 AND，都是原来数值，因而前三个数不变，为 10.100.122。后面一个 0，转换成二进制是 0，0 和任何数值取 AND，都是 0，因而最后一个数变为 0，合起来就是 10.100.122.0。这就是网络号。将子网掩码和 IP 地址按位计算 AND，就可得到网络号**


#### 公有 IP 地址和私有 IP 地址

平时我们看到的数据中心里，办公室、家里或学校的 IP 地址，一般都是私有 IP 地址段。因为这些地址允许组织内部的 IT 人员自己管理、自己分配，而且可以重复。因此，你学校的某个私有 IP 地址段和我学校的可以是一样的

公有 IP 地址有个组织统一分配，你需要去买。如果你搭建一个网站，给你学校的人使用，让你们学校的 IT 人员给你一个 IP 地址就行。但是假如你要做一个类似网易 163 这样的网站，就需要有公有 IP 地址，这样全世界的人才能访问


表格中的 `192.168.0.x` 是最常用的私有 IP 地址。你家里有 `Wi-Fi`，对应就会有一个 IP 地址。一般你家里地上网设备不会超过 256 个，所以 `/24` 基本就够了。有时候我们也能见到 `/16` 的 CIDR，这两种是最常见的，也是最容易理解的


不需要将十进制转换为二进制 32 位，就能明显看出 `192.168.0` 是网络号，后面是主机号。而整个网络里面的第一个地址 `192.168.0.1`，往往就是你这个私有网络的出口地址。例如，你家里的电脑连接 Wi-Fi，Wi-Fi 路由器的地址就是 `192.168.0.1`，而 `192.168.0.255` 就是**广播地址**。一旦发送这个地址，整个 `192.168.0` 网络里面的所有机器都能收到


#### 一个容易犯错的 CIDR
我们来看 `16.158.165.91/22` 这个 CIDR。求一下这个网络的第一个地址、子网掩码和广播地址?

`/22` 不是 8 的整数倍，不好办，只能先变成二进制来看。`16.158` 的部分不会动，它占了前 16 位。中间的 165，变为二进制为‭`10100101‬`。除了前面的 16 位，还剩 6 位。所以，这 8 位中前 6 位是网络号，`16.158.<101001>`，而 `<01>.91` 是机器号。


第一个地址是 `16.158.<101001><00>.1`，即 `16.158.164.1`。子网掩码是 `255.255.<111111><00>.0`，即 `255.255.252.0`。广播地址为 `16.158.<101001><11>.255`，即 `16.158.167.255`


在 IP 地址的后面有个 scope，对于 `eth0` 这张网卡来讲，是 `globa`l，说明这张网卡是可以对外的，可以接收来自各个地方的包。对于 `lo` 来讲，是 `host`，说明这张网卡仅仅可以供本机相互通信

lo 全称是 `loopback`，又称**环回接口**，往往会被分配到 `127.0.0.1` 这个地址。这个地址用于本机通信，经过内核处理后直接返回，不会在任何网络中出现

#### MAC 地址

在 IP 地址的上一行是 `link/ether fa:16:3e:c7:79:75 brd ff:ff:ff:ff:ff:ff`，这个被称为 **MAC 地址**，是一个网卡的物理地址，用十六进制，6 个 byte 表示


MAC 地址是一个很容易让人误解的地址。因为 MAC 地址号称全局唯一，不会有两个网卡有相同的 MAC 地址，而且网卡自生产出来，就带着这个地址。很多人看到这里就会想，既然这样，整个互联网的通信，全部用 MAC 地址好了，只要知道了对方的 MAC 地址，就可以把信息传过去


这样当然是不行的。 **一个网络包要从一个地方传到另一个地方，除了要有确定的地址，还需要有定位功能。 而有门牌号码属性的 IP 地址，才是有远程定位功能的**

你去北京市雍和路 599 号 B 楼 6 层找A，你在路上问路，可能被问的人不知道 B 楼是哪个，但是可以给你指雍和路怎么去。但是如果你问一个人，你知道这个身份证号的人在哪里吗？可想而知，没有人知道


**MAC 地址更像是身份证，是一个唯一的标识。它的唯一性设计是为了组网的时候，不同的网卡放在一个网络里面的时候，可以不用担心冲突。从硬件角度，保证不同的网卡有不同的标识**


**MAC 地址是有一定定位功能的，只不过范围非常有限**

MAC 地址的通信范围比较小，局限在一个子网里面。例如，从 `192.168.0.2/24` 访问 `192.168.0.3/24` 是可以用 MAC 地址的。一旦跨子网，即从 `192.168.0.2/24` 到 `192.168.1.2/24`，MAC 地址就不行了，需要 IP 地址起作用了


#### 网络设备的状态标识

解析完了 MAC 地址，我们再来看`BROADCAST,MULTICAST,UP,LOWER_UP`是干什么的？这个叫做 `net_device flags`，**网络设备的状态标识**

**UP 表示网卡处于启动的状态；BROADCAST 表示这个网卡有广播地址，可以发送广播包；MULTICAST 表示网卡可以发送多播包；LOWER_UP 表示 L1 是启动的，也即网线插着呢。MTU1500 是指什么意思呢？是哪一层的概念呢？最大传输单元 MTU 为 1500，这是以太网的默认值**


我们讲过网络包是层层封装的。MTU 是二层 MAC 层的概念。MAC 层有 MAC 的头，以太网规定连 MAC 头带正文合起来，不允许超过 1500 个字节。正文里面有 IP 的头、TCP 的头、HTTP 的头。如果放不下，就需要分片来传输


#### 阶段小结
- IP 是地址，有定位功能；MAC 是身份证，无定位功能
- CIDR 可以用来判断是不是本地人
- IP 分公有的 IP 和私有的 IP


### DHCP与PXE：IP是怎么来的，又是怎么没的？

