### HTTP 历史

1. HTTP/0.9

20 世纪 90 年代初期的互联网世界非常简陋，计算机处理能力低，存储容量小，网速很慢，还是一片信息荒漠。网络上绝大多数的资源都是纯文本，很多通信协议也都使用纯文本，所以 HTTP 的设计也不可避免地受到了时代的限制

这一时期的 HTTP 被定义为 0.9 版，结构比较简单，为了便于服务器和客户端处理，它也采用了纯文本格式。蒂姆·伯纳斯 - 李最初设想的系统里的文档都是只读的，所以只允许用`GET`动作从服务器上获取 HTML 文档，并且在响应请求之后立即关闭连接，功能非常有限

2. HTTP/1.0

HTTP/1.0 版本在 1996 年正式发布。它在多方面增强了 0.9 版，形式上已经和我们现在的 HTTP 差别不大了，例如:
- 增加了 HEAD、POST 等新方法
- 增加了响应状态码，标记可能的错误原因
- 引入了协议版本号概念
- 引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活
- 传输的数据不再仅限于文本

但 HTTP/1.0 并不是一个标准，只是记录已有实践和模式的一份参考文档，不具有实际的约束力，相当于一个备忘录

3. HTTP/1.1

从版本号我们就可以看到，HTTP/1.1 是对 HTTP/1.0 的小幅度修正。但一个重要的区别是：它是一个正式的标准，而不是一份可有可无的参考文档。这意味着今后互联网上所有的浏览器、服务器、网关、代理等等，只要用到 HTTP 协议，就必须严格遵守这个标准，相当于是互联网世界的一个立法

HTTP/1.1 主要的变更点有:
- 增加了 PUT、DELETE 等新的方法
- 增加了缓存管理和控制
- 明确了连接管理，允许持久连接
- 允许响应数据分块（chunked），利于传输大文件
- 强制要求 Host 头，让互联网主机托管成为可能

HTTP/1.1 的推出可谓是众望所归，开启了后续的Web 1.0, Web 2.0时代

4. HTTP/2.0

HTTP/1.1 发布之后，整个互联网世界呈现出了爆发式的增长, 这期间也出现了一些对 HTTP 不满的意见，主要就是连接慢，无法跟上迅猛发展的互联网，但 HTTP/1.1 标准一直岿然不动，无奈之下人们只好发明各式各样的小花招来缓解这些问题，比如以前常见的切图、JS 合并等网页优化手段

Google 把 SPDY 推上了标准的宝座，互联网标准化组织以 SPDY 为基础开始制定新版本的 HTTP 协议，最终在 2015 年发布了 HTTP/2，RFC 编号 7540

HTTP/2 的制定充分考虑了现今互联网的现状：宽带、移动、不安全，在高度兼容 HTTP/1.1 的同时在性能改善方面做了很大努力，主要的特点有:
- 二进制协议，不再是纯文本
- 可发起多个请求，废弃了 1.1 里的管道
- 使用专用算法压缩头部，减少数据传输量
- 允许服务器主动向客户端推送数据
- 增强了安全性，事实上要求加密通信

虽然 HTTP/2 到今天已经四年了，也衍生出了 gRPC 等新协议，但由于 HTTP/1.1 实在是太过经典和强势，目前它的普及率还比较低，大多数网站使用的仍然还是 20 年前的 HTTP/1.1

5. HTTP/3

在 HTTP/2 还处于草案之时，Google 又发明了一个新的协议，叫做 QUIC，而且还是相同的套路，继续在 Chrome 和自家服务器里试验着玩，依托它的庞大用户量和数据量，持续地推动 QUIC 协议成为互联网上的既成事实

2018 年，互联网标准化组织 IETF 提议将`HTTP over QUIC`更名为`HTTP/3`并获得批准，HTTP/3 正式进入了标准化制订阶段，也许两三年后就会正式发布，到时候我们很可能会跳过 HTTP/2 直接进入 HTTP/3

### HTTP是什么

HTTP 就是超文本传输协议，也就是 HyperText Transfer Protocol

超文本传输协议:
- 超文本
- 传输
- 协议

HTTP 是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式

计算机和网络世界里有数不清的各种角色：CPU、内存、总线、磁盘、操作系统、浏览器、网关、服务器……这些角色之间相互通信也必然会有各式各样、五花八门的协议，用处也各不相同，例如广播协议、寻址协议、路由协议、隧道协议、选举协议等等

HTTP 是一个传输协议，所谓的传输（Transfer）其实很好理解，就是把一堆东西从 A 点搬到 B 点，或者从 B 点搬到 A 点

HTTP 协议是一个双向协议，也就是说，有两个最基本的参与者 A 和 B，从 A 开始到 B 结束，数据在 A 和 B 之间双向而不是单向流动。通常我们把先发起传输动作的 A 叫做请求方，把后接到传输的 B 叫做应答方或者响应方

数据虽然是在 A 和 B 之间传输，但并没有限制只有 A 和 B 这两个角色，允许中间有中转或者接力，这样，传输方式就从`A<===>B`，变成了`A<=>X<=>Y<=>Z<=>B`，A 到 B 的传输过程中可以存在任意多个“中间人”，而这些中间人也都遵从 HTTP 协议，只要不打扰基本的数据传输，就可以添加任意的额外功能，例如安全认证、数据压缩、编码转换等等，优化整个传输过程

即**HTTP 是一个在计算机世界里专门用来在两点之间传输数据的约定和规范**

所谓文本（Text），就表示 HTTP 传输的不是 TCP/UDP 这些底层协议里被切分的杂乱无章的二进制包，而是完整的、有意义的数据，可以被浏览器、服务器这样的上层应用程序处理

在互联网早期，文本只是简单的字符文字，但发展到现在，文本的涵义已经被大大地扩展了，图片、音频、视频、甚至是压缩包，在 HTTP 眼里都可以算做是文本

所谓超文本，就是超越了普通文本的文本，它是文字、图片、音频和视频等的混合体，最关键的是含有超链接，能够从一个超文本跳跃到另一个超文本，形成复杂的非线性、网状的结构关系

对于超文本，我们最熟悉的就应该是 HTML 了，它本身只是纯文字文件，但内部用很多标签定义了对图片、音频、视频等的链接，再经过浏览器的解释，呈现在我们面前的就是一个含有多种视听信息的页面

**在互联网世界里，HTTP 通常跑在 TCP/IP 协议栈之上，依靠 IP 协议实现寻址和路由、TCP 协议实现可靠数据传输、DNS 协议实现域名查找、SSL/TLS 协议实现安全通信。此外，还有一些协议依赖于 HTTP，例如 WebSocket、HTTPDNS 等。这些协议相互交织，构成了一个协议网，而 HTTP 则处于中心地位**


### HTTP相关的各种概念

互联网的正式名称是 Internet，里面存储着无穷无尽的信息资源，我们通常所说的上网实际上访问的只是互联网的一个子集万维网（World Wide Web），它基于 HTTP 协议，传输 HTML 等超文本资源，能力也就被限制在 HTTP 协议之内。互联网上还有许多万维网之外的资源，例如常用的电子邮件、BT 和 Magnet 点对点下载、FTP 文件下载、SSH 安全登录、各种即时通信服务等等，它们需要用各自的专有协议来访问。不过由于 HTTP 协议非常灵活、易于扩展，而且超文本的表述能力很强，所以很多其他原本不属于 HTTP 的资源也可以“包装”成 HTTP 来访问，这就是我们为什么能够总看到各种“网页应用”——例如微信网页版,邮箱网页版的原因

#### 1.浏览器

上网就要用到浏览器，常见的浏览器有 Google 的 Chrome、Mozilla 的 Firefox、Apple 的 Safari、Microsoft 的 IE 和 Edge

浏览器本质上是一个 HTTP 协议中的请求方，使用 HTTP 协议获取网络上的各种资源。当然，为了让我们更好地检索查看网页，它还集成了很多额外的功能

在 HTTP 协议里，浏览器的角色被称为`User Agent`即用户代理，意思是作为访问者的代理来发起 HTTP 请求。不过在不引起混淆的情况下，我们通常都简单地称之为`客户端`

#### 2.Web 服务器

Web 服务器是一个很大也很重要的概念，它是 HTTP 协议里响应请求的主体，通常也把控着绝大多数的网络资源，在网络世界里处于强势地位

Nginx 是 Web 服务器里的后起之秀，特点是高性能、高稳定，且易于扩展。在高流量的网站里更是不二之选

#### 3.CDN

浏览器和服务器是 HTTP 协议的两个端点, 浏览器通常不会直接连到服务器，中间会经过重重关卡，其中的一个重要角色就叫做 CDN

CDN，全称是`Content Delivery Network`，翻译过来就是内容分发网络。它应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求

它可以缓存源站的数据，让浏览器的请求不用千里迢迢地到达源站服务器，直接在半路就可以获取响应。如果 CDN 的调度算法很优秀，更可以找到离用户最近的节点，大幅度缩短响应时间

CDN 也是现在互联网中的一项重要基础设施，除了基本的网络加速外，还提供负载均衡、安全防护、边缘计算、跨运营商网络等功能，能够成倍地放大源站服务器的服务能力，很多云服务商都把 CDN 作为产品的一部分

#### 4.爬虫

但 HTTP 协议并没有规定用户代理后面必须是真正的人类，它也完全可以是机器人，这些机器人的正式名称就叫做爬虫（Crawler），实际上是一种可以自动访问 Web 资源的应用程序

爬虫也有不好的一面，它会过度消耗网络资源，占用服务器和带宽，影响网站对真实数据的分析，甚至导致敏感信息泄漏。所以，又出现了反爬虫技术，通过各种手段来限制爬虫。其中一项就是君子协定`robots.txt`，约定哪些该爬，哪些不该爬

无论是爬虫还是反爬虫，用到的基本技术都是两个，一个是 HTTP，另一个就是 HTML

#### 5.HTML

HTML 是 HTTP 协议传输的主要内容之一，它描述了超文本页面，用各种标签定义文字、图片等资源和排版布局，最终由浏览器渲染出可视化页面

#### 6.WAF

WAF 意思是网络应用防火墙。与硬件防火墙类似，它是应用层面的防火墙，专门检测 HTTP 流量，是防护 Web 应用的安全技术。WAF 通常位于 Web 服务器之前，可以阻止如 SQL 注入、跨站脚本等攻击，目前应用较多的一个开源项目是 ModSecurity，它能够完全集成进 Apache 或 Nginx

### 与HTTP相关的各种协议

#### 1.TCP/IP

TCP/IP 协议实际上是一系列网络通信协议的统称，其中最核心的两个协议是 TCP 和 IP，其他的还有 UDP、ICMP、ARP 等等，共同构成了一个复杂但有层次的协议栈

这个协议栈有四层，最上层是应用层，最下层是链接层，TCP 和 IP 则在中间：TCP 属于传输层，IP 属于网际层。协议的层级关系模型非常重要

- IP 协议是`Internet Protocol`的缩写，主要目的**是解决寻址和路由问题**，以及如何在两点间传送数据包。IP 协议使用“IP 地址”的概念来定位互联网上的每一台计算机
- TCP 协议是`Transmission Control Protocol`的缩写，意思是传输控制协议，它位于 IP 协议之上，基于 IP 协议提供可靠的、字节流形式的通信，是 HTTP 协议得以实现的基础

现在我们使用的 IP 协议大多数是 v4 版，地址是四个用`.`分隔的数字，例如`192.168.0.1`，总共有 `2^32`，大约 42 亿个可以分配的地址。看上去好像很多，但互联网的快速发展让地址的分配管理很快就捉襟见肘。所以，就又出现了 v6 版，使用 8 组`:`分隔的数字作为地址，容量扩大了很多，有 `2^128` 个，在未来的几十年里应该是足够用了

可靠是指保证数据不丢失，字节流是指保证数据完整，所以在 TCP 协议的两端可以如同操作文件一样访问传输的数据，就像是读写在一个密闭的管道里“流动”的字节

**HTTP 是一个传输协议，但它不关心寻址、路由、数据完整性等传输细节，而要求这些工作都由下层来处理。因为互联网上最流行的是 TCP/IP 协议，而它刚好满足 HTTP 的要求，所以互联网上的 HTTP 协议就运行在了 TCP/IP 上，HTTP 也就可以更准确地称为`HTTP over TCP/IP`**


#### 2.DNS

域名系统（Domain Name System）用有意义的名字来作为 IP 地址的等价替代

在 DNS 中，域名（Domain Name）又称为主机名（Host），为了更好地标记不同国家或组织的主机，让名字更好记，所以被设计成了一个有层次的结构

域名用`.`分隔成多个单词，级别从左到右逐级升高，最右边的被称为顶级域名。对于顶级域名，可能你随口就能说出几个，例如表示商业公司的`com`、表示教育机构的`edu`

但想要使用 TCP/IP 协议来通信仍然要使用 IP 地址，所以需要把域名做一个转换，映射到它的真实 IP，这就是所谓的**域名解析**

#### 3.URI/URL

DNS 和 IP 地址只是标记了互联网上的主机，但主机上有那么多文本、图片、页面，到底要找哪一个呢？

`URI`（Uniform Resource Identifier），中文名称是 **统一资源标识符**，使用它就能够唯一地标记互联网上资源

`URI` 另一个更常用的表现形式是 URL（Uniform Resource Locator）， **统一资源定位符**，也就是我们俗称的网址，它实际上是 URI 的一个子集，不过因为这两者几乎是相同的，差异不大，所以通常不会做严格的区分

URI 主要有三个基本的部分构成:
- 协议名：即访问该资源应当使用的协议，在这里是`http`
- 主机名：即互联网上主机的标记，可以是域名或 IP 地址，在这里是`nginx.org`
- 路径：即资源在主机上的位置，使用`/`分隔多级目录，在这里是`/en/download.html`


#### 4.HTTPS

HTTPS 它的全称是`HTTP over SSL/TLS`，也就是运行在 SSL/TLS 协议上的 HTTP, 这里是 SSL/TLS，而不是 TCP/IP，它是一个负责加密通信的安全协议，建立在 TCP/IP 之上，所以也是个可靠的传输协议，可以被用作 HTTP 的下层

HTTPS 相当于`HTTP+SSL/TLS+TCP/IP`

SSL 使用了许多密码学最先进的研究成果，综合了对称加密、非对称加密、摘要算法、数字签名、数字证书等技术，能够在不安全的环境中为通信的双方创建出一个秘密的、安全的传输通道，为 HTTP 套上一副坚固的盔甲


#### 5.代理

代理（Proxy）是 HTTP 协议中请求方和应答方中间的一个环节，作为中转站，既可以转发客户端的请求，也可以转发服务器的应答

- 匿名代理：完全隐匿了被代理的机器，外界看到的只是代理服务器
- 透明代理：顾名思义，它在传输过程中是透明开放的，外界既知道代理，也知道客户端
- 正向代理：靠近客户端，代表客户端向服务器发送请求
- 反向代理：靠近服务器端，代表服务器响应客户端的请求

CDN实际上就是一种代理，它代替源站服务器响应客户端的请求，通常扮演着透明代理和反向代理的角色

由于代理在传输过程中插入了一个中间层，所以可以在这个环节做很多有意思的事情，比如：
- 负载均衡：把访问请求均匀分散到多台机器，实现访问集群化
- 内容缓存：暂存上下行的数据，减轻后端的压力
- 安全防护：隐匿 IP, 使用 WAF 等工具抵御网络攻击，保护被代理的机器
- 数据处理：提供压缩、加密等额外的功能


### 常说的`四层`和`七层`到底是什么

- 四层负载均衡
- 七层负载均衡
- 二层转发
- 三层路由

#### TCP/IP 网络分层模型

TCP/IP 协议总共有四层，每一层需要下层的支撑，同时又支撑着上层

- 第一层叫链接层（link layer），负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标记网络上的设备，所以有时候也叫 MAC 层
- 第二层叫网际层（internet layer），IP 协议就处在这一层。因为 IP 协议定义了`IP 地址`的概念，所以就可以在`链接层`的基础上，用 IP 地址取代 MAC 地址，把许许多多的局域网、广域网连接成一个虚拟的巨大网络，在这个网络里找设备时只要把 IP 地址再翻译成 MAC 地址就可以了
- 第三层叫传输层（transport layer），这个层次协议的职责是保证数据在 IP 地址标记的两点之间可靠地传输，是 TCP 协议工作的层次，另外还有它的一个小伙伴UDP
- 协议栈的第四层叫应用层（application layer），由于下面的三层把基础打得非常好，所以在这一层就百花齐放了，有各种面向具体应用的协议。例如 Telnet、SSH、FTP、SMTP 等等，当然还有我们的 HTTP


TCP 是一个有状态的协议，需要先与对方建立连接然后才能发送数据，而且保证数据不丢失不重复。而 UDP 则比较简单，它无状态，不用事先建立连接就可以任意发送数据，但不保证数据一定会发到对方。两个协议的另一个重要区别在于数据的形式。TCP 的数据是连续的字节流，有先后顺序，而 UDP 则是分散的小数据包，是顺序发，乱序收

关于 TCP 和 UDP 可以展开讨论的话题还有很多:
- 三次握手
- 四次挥手

**MAC 层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包**


#### OSI 网络分层模型

OSI 模型分成了七层，部分层次与 TCP/IP 很像，从下到上分别是：
- 第一层：物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等等
- 第二层：数据链路层，它基本相当于 TCP/IP 的链接层
- 第三层：网络层，相当于 TCP/IP 里的网际层
- 第四层：传输层，相当于 TCP/IP 里的传输层
- 第五层：会话层，维护网络中的连接状态，即保持会话和同步
- 第六层：表示层，把数据转换为合适、可理解的语法和语义
- 第七层：应用层，面向具体的应用传输数据

在 OSI 模型之后，四层, 七层 这样的说法就逐渐流行开了

**所谓的`四层负载均衡`就是指工作在传输层上，基于 TCP/IP 协议的特性，例如 IP 地址、端口号等实现对后端服务器的负载均衡**

**所谓的`七层负载均衡`就是指工作在应用层上，看到的是 HTTP 协议，解析 HTTP 报文里的 URI、主机名、资源类型等数据，再用适当的策略转发给后端服务器**

**二层转发：设备工作在链路层，帧在经过交换机设备时，检查帧的头部信息，拿到目标mac地址，进行本地转发和广播**

**三层路由：设备工作在ip层，报文经过有路由功能的设备时，设备分析报文中的头部信息，拿到ip地址，根据网段范围，进行本地转发或选择下一个网关**

#### TCP/IP 协议栈的工作方式

1. 假设你想把一件毛绒玩具送给朋友，但你要先拿个塑料袋套一下，这件玩具就相当于 HTTP 协议里要传输的内容，比如 HTML，然后 HTTP 协议为它加一个 HTTP 专用附加数据
2. 你把玩具交给快递小哥，为了保护货物，他又加了层包装再贴了个标签，相当于在 TCP 层给数据再次打包，加上了 TCP 头
3. 接着快递小哥下楼，把包裹放进了三轮车里，运到集散点，然后再装进更大的卡车里，相当于在 IP 层、MAC 层对 TCP 数据包加上了 IP 头、MAC 头
4. 之后经过漫长的运输，包裹到达目的地，要卸货再放进另一位快递员的三轮车，就是在 IP 层、MAC 层传输后拆包
5. 快递员到了你朋友的家门口，撕掉标签，去除了 TCP 层的头，你朋友再拆掉塑料袋包装，也就是 HTTP 头，最后就拿到了玩具，也就是真正的 HTML 页面

**HTTP 协议的传输过程就是这样通过协议栈逐层向下，每一层都添加本层的专有数据，层层打包，然后通过下层发送出去, 接收数据则是相反的操作，从下往上穿过协议栈，逐层拆包，每层去掉本层的专有头，上层就会拿到自己的数据**

但下层的传输过程对于上层是完全透明的，上层也不需要关心下层的具体实现细节，所以就 HTTP 层次来看，它不管下层是不是 TCP/IP 协议，看到的只是一个可靠的传输链路，只要把数据加上自己的头，对方就能原样收到

### 域名那些事

在 IP 地址之上再来一次抽象，把数字形式的 IP 地址转换成更有意义更好记的名字，在字符串的层面上再增加新玩法。于是，`DNS 域名系统`就这么出现了

#### 域名的形式

域名是一个有层次的结构，是一串用`.`分隔的多个单词，最右边的被称为`顶级域名`，然后是`二级域名`，层级关系向左依次降低

最左边的是主机名，通常用来表明主机的用途，比如`www`表示提供万维网服务、`mail`表示提供邮件服务

看一下这个的域名`time.ifcalm.org`，这里的`org`就是顶级域名，`ifcalm`是二级域名，`time`则是主机名。使用这个域名，DNS 就会把它转换成相应的 IP 地址，你就可以访问网站了

**域名不仅能够代替 IP 地址，还有许多其他的用途**

在 Apache、Nginx 这样的 Web 服务器里，域名可以用来标识虚拟主机，决定由哪个虚拟主机来对外提供服务

域名本质上还是个名字空间系统，使用多级域名就可以划分出不同的国家、地区、组织、公司、部门，每个域名都是独一无二的，可以作为一种身份的标识

因为这个特性，域名也被扩展到了其他应用领域，比如 Java 的包机制就采用域名作为命名空间，只是它使用了反序

#### 域名的解析

就像 IP 地址必须转换成 MAC 地址才能访问主机一样，域名也必须要转换成 IP 地址，这个过程就是**域名解析**

DNS 的核心系统是一个三层的树状、分布式服务，基本对应域名的结构：
1. 根域名服务器（Root DNS Server）：管理顶级域名服务器，返回`com`, `net`, `cn`等顶级域名服务器的 IP 地址
2. 顶级域名服务器（Top-level DNS Server）：管理各自域名下的权威域名服务器，比如 com 顶级域名服务器可以返回 apple.com 域名服务器的 IP 地址
3. 权威域名服务器（Authoritative DNS Server）：管理自己域名下主机的 IP 地址，比如 apple.com 权威域名服务器可以返回 www.apple.com 的 IP 地址


在这里**根域名服务器**是关键，它必须是众所周知的，否则下面的各级服务器就无从谈起了。目前全世界共有 13 组根域名服务器，又有数百台的镜像，保证一定能够被访问到

有了这个系统以后，任何一个域名都可以在这个树形结构里从顶至下进行查询，就好像是把域名从右到左顺序走了一遍，最终就获得了域名对应的 IP 地址

例如，你要访问`www.apple.com`，就要进行下面的三次查询：
1. 访问根域名服务器，它会告诉你`com`顶级域名服务器的地址
2. 访问`com`顶级域名服务器，它再告诉你`apple.com`域名服务器的地址
3. 最后访问`apple.com`域名服务器，就得到了`www.apple.com`的地址

虽然核心的 DNS 系统遍布全球，服务能力很强也很稳定，但如果全世界的网民都往这个系统里挤，即使不挤瘫痪了，访问速度也会很慢。所以在核心 DNS 系统之外，还有两种手段用来减轻域名解析的压力，并且能够更快地获取结果，基本思路就是**缓存**

首先，许多大公司、网络运行商都会建立自己的 DNS 服务器，作为用户 DNS 查询的代理，代替用户访问核心 DNS 系统。这些服务器被称为`非权威域名服务器`，可以缓存之前的查询结果，如果已经有了记录，就无需再向根服务器发起查询，直接返回对应的 IP 地址

这些 DNS 服务器的数量要比核心系统的服务器多很多，而且大多部署在离用户很近的地方。比较知名的 DNS 有 Google 的`8.8.8.8`，Microsoft 的`4.2.2.1`，还有 CloudFlare 的`1.1.1.1`等等

其次，操作系统里也会对 DNS 解析结果做缓存，如果你之前访问过`www.apple.com`，那么下一次在浏览器里再输入这个网址的时候就不会再跑到 DNS 那里去问了，直接在操作系统里就可以拿到 IP 地址

另外，操作系统里还有一个特殊的主机映射文件，通常是一个可编辑的文本，在 Linux 里是`/etc/hosts`，在 Windows 里是`C:\WINDOWS\system32\drivers\etc\hosts`，如果操作系统在缓存里找不到 DNS 记录，就会找这个文件

有了上面的DNS 服务器、操作系统缓存和 hosts 文件后，很多域名解析的工作就都不用跋山涉水了，直接在本地或本机就能解决，不仅方便了用户，也减轻了各级 DNS 服务器的压力，效率就大大提升了

#### 域名新玩法

第一种，也是最简单的，**重定向**。因为域名代替了 IP 地址，所以可以让对外服务的域名不变，而主机的 IP 地址任意变动。当主机有情况需要下线、迁移时，可以更改 DNS 记录，让域名指向其他的机器

第二种，因为域名是一个名字空间，所以可以使用 bind9 等开源软件搭建一个在内部使用的 DNS，作为名字服务器。这样我们开发的各种内部服务就都用域名来标记，比如数据库服务都用域名`mysql.inner.app`，商品服务都用`goods.inner.app`，发起网络通信时也就不必再使用写死的 IP 地址了，可以直接用域名

第三种玩法包含了前两种，也就是基于域名实现的负载均衡:
- 第一种方式，因为域名解析可以返回多个 IP 地址，所以一个域名可以对应多台主机，客户端收到多个 IP 地址后，就可以自己使用轮询算法依次向服务器发起请求，实现负载均衡
- 第二种方式，域名解析可以配置内部的策略，返回离客户端最近的主机，或者返回当前服务质量最好的主机，这样在 DNS 端把请求分发到不同的服务器，实现负载均衡


1. 域名屏蔽，对域名直接不解析，返回错误，让你无法拿到 IP 地址，也就无法访问网站
2. 域名劫持，也叫域名污染，你要访问 A 网站，但 DNS 给了你 B 网站


### 键入网址再按下回车，后面究竟发生了什么

HTTP 协议是运行在 TCP/IP 基础上的，依靠 TCP/IP 协议来实现数据的可靠传输。所以浏览器要用 HTTP 协议收发数据，首先要做的就是建立 TCP 连接

浏览器要依照 TCP 协议的规范，使用**三次握手**建立与 Web 服务器的连接

经过 SYN、SYN/ACK、ACK 的三个包之后，浏览器与服务器的 TCP 连接就建立起来了

有了可靠的 TCP 连接通道后，HTTP 协议就可以开始工作了

#### 浏览器 HTTP 请求过程

1. 浏览器从地址栏的输入中获得服务器的 IP 地址和端口号
2. 浏览器用 TCP 的三次握手与服务器建立连接
3. 浏览器向服务器发送拼好的报文
4. 服务器收到报文后处理请求，同样拼好报文再发给浏览器
5. 浏览器解析报文，渲染输出页面

#### 使用域名访问 Web 服务器

浏览器看到了网址里的`www.ifcalm.net`，发现它不是数字形式的 IP 地址，那就肯定是域名了，于是就会发起域名解析动作，通过访问一系列的域名解析服务器，试图把这个域名翻译成 TCP/IP 协议里的 IP 地址

在域名解析的过程中会有多级的缓存，浏览器首先看一下自己的缓存里有没有，如果没有就向操作系统的缓存要，还没有就检查本机域名解析文件 hosts

#### 真实的网络世界

接入网络的同时，网络运行商会给你的设备分配一个 IP 地址，这个地址可能是静态分配的，也可能是动态分配的。静态 IP 就始终不变，而动态 IP 可能你下次上网就变了

假设你要访问的是 Apple 网站，显然你是不知道它的真实 IP 地址的，在浏览器里只能使用域名`www.apple.com`访问，那么接下来要做的必然是域名解析。这就要用 DNS 协议开始从操作系统、本地 DNS、根 DNS、顶级 DNS、权威 DNS 的层层解析，当然这中间有缓存，可能不会费太多时间就能拿到结果

互联网上还有另外一个重要的角色 CDN，DNS 解析可能会给出 CDN 服务器的 IP 地址，这样你拿到的就会是 CDN 服务器而不是目标网站的实际地址

因为 CDN 会缓存网站的大部分资源，比如图片、CSS 样式表，所以有的 HTTP 请求就不需要再发到 Apple，CDN 就可以直接响应你的请求，把数据发给你

由 PHP、Java 等后台服务动态生成的页面属于动态资源，CDN 无法缓存，只能从目标网站获取。于是你发出的 HTTP 请求就要开始在互联网上的“漫长跋涉”，经过无数的路由器、网关、代理，最后到达目的地

目标网站的服务器对外表现的是一个 IP 地址，但为了能够扛住高并发，在内部也是一套复杂的架构。通常在入口是负载均衡设备，例如四层的 LVS 或者七层的 Nginx，在后面是许多的服务器，构成一个更强更稳定的集群

负载均衡设备会先访问系统里的缓存服务器，通常有 memory 级缓存 Redis 和 disk 级缓存 Varnish，它们的作用与 CDN 类似，不过是工作在内部网络里，把最频繁访问的数据缓存几秒钟或几分钟，减轻后端应用服务器的压力

如果缓存服务器里也没有，那么负载均衡设备就要把请求转发给应用服务器了。这里就是各种开发框架大显神通的地方了，例如 Java 的 Tomcat/Netty/Jetty，Python 的 Django，还有 PHP、Node.js、Golang 等等。它们又会再访问后面的 MySQL、PostgreSQL、MongoDB 等数据库服务，实现用户登录、商品查询、购物下单、扣款支付等业务操作，然后把执行的结果返回给负载均衡设备，同时也可能给缓存服务器里也放一份

应用服务器的输出到了负载均衡设备这里，请求的处理就算是完成了，就要按照原路再走回去，还是要经过许多的路由器、网关、代理。如果这个资源允许缓存，那么经过 CDN 的时候它也会做缓存，这样下次同样的请求就不会到达源站了

最后网站的响应数据回到了你的设备，它可能是 HTML、JSON、图片或者其他格式的数据，需要由浏览器解析处理才能显示出来，如果数据里面还有超链接，指向别的资源，那么就又要重走一遍整个流程，直到所有的资源都下载完


### HTTP报文

HTTP 协议的核心部分是: 它传输的报文内容

HTTP 协议与 TCP/UDP 类似，同样也需要在实际传输的数据前附加一些头数据，不过与 TCP/UDP 不同的是，它是一个纯文本的协议，所以头数据都是 `ASCII` 码的文本，可以很容易地用肉眼阅读，不用借助程序解析也能够看懂

HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成:

- 起始行（start line）：描述请求或响应的基本信息
- 头部字段集合（header）：使用 key-value 形式更详细地说明报文
- 消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据

其中前两部分起始行和头部字段经常又合称为`请求头`或`响应头`，消息正文又称为实体，但与`header`对应，很多时候就直接称为`body`

HTTP 协议规定报文必须有 `header`，但可以没有 `body`，而且在 `header` 之后必须要有一个空行，也就是`CRLF`，十六进制的`0D0A`

#### 请求行

它简要地描述了客户端想要如何操作服务器端的资源

请求行由三部分构成：
- 请求方法：是一个动词，如 GET/POST，表示对资源的操作
- 请求目标：通常是一个 URI，标记了请求方法要操作的资源
- 版本号：表示报文使用的 HTTP 协议版本

这三个部分通常使用空格来分隔，最后要用 CRLF 换行表示结束

#### 状态行

响应报文里的起始行，在这里它不叫响应行，而是叫状态行，意思是服务器响应的状态

比起请求行来说，状态行要简单一些，同样也是由三部分构成：
- 版本号：表示报文使用的 HTTP 协议版本
- 状态码：一个三位数，用代码的形式表示处理的结果，比如 200 是成功，500 是服务器错误
- 原因：作为数字状态码补充，是更详细的解释文字，帮助人理解原因

#### 头部字段

请求行或状态行再加上头部字段集合就构成了 HTTP 报文里完整的请求头或响应头

头部字段是 key-value 的形式，key 和 value 之间用`:`分隔，最后用 CRLF 换行表示字段结束

HTTP 头字段非常灵活，不仅可以使用标准里的 Host、Connection 等已有头，也可以任意添加自定义头，这就给 HTTP 协议带来了无限的扩展可能

**使用头字段需要注意下面几点：**
- 字段名不区分大小写，例如`Host`也可以写成`host`，但首字母大写的可读性更好
- 字段名里不允许出现空格，可以使用连字符`-`，但不能使用下划线`_`。例如，`test-name`是合法的字段名，而`test name`, `test_name`是不正确的字段名
- 字段名后面必须紧接着`:`，不能有空格，而`:`后的字段值前可以有多个空格
- 字段的顺序是没有意义的，可以任意排列不影响语义
- 字段原则上不能重复，除非这个字段本身的语义允许，例如 `Set-Cookie`

#### 常用头字段

- 通用字段：在请求头和响应头里都可以出现
- 请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件
- 响应字段：仅能出现在响应头里，补充说明响应报文的信息
- 实体字段：它实际上属于通用字段，但专门描述 body 的额外信息


1. Host 字段: 它属于请求字段，只能出现在请求头里，它同时也是唯一一个 `HTTP/1.1` 规范里要求必须出现的字段，也就是说，如果请求头里没有 `Host`，那这就是一个错误的报文, Host 字段告诉服务器这个请求应该由哪个主机来处理，当一台计算机上托管了多个虚拟主机的时候，服务器端就需要用 Host 字段来选择
2. `User-Agent` 是请求字段，只出现在请求头里。它使用一个字符串来描述发起 HTTP 请求的客户端，服务器可以依据它来返回最合适此浏览器显示的页面
3. `Date` 字段是一个通用字段，但通常出现在响应头里，表示 HTTP 报文创建的时间，客户端可以使用这个时间再搭配其他字段决定缓存策略
4. `Server` 字段是响应字段，只能出现在响应头里。它告诉客户端当前正在提供 Web 服务的软件名称和版本号. Server 字段也不是必须要出现的，因为这会把服务器的一部分信息暴露给外界，如果这个版本恰好存在 bug，那么黑客就有可能利用 bug 攻陷服务器。所以，有的网站响应头里要么没有这个字段，要么就给出一个完全无关的描述信息
5. 实体字段里要说的一个是 `Content-Length`，它表示报文里 body 的长度，也就是请求头或响应头空行后面数据的长度。服务器看到这个字段，就知道了后续有多少数据，可以直接接收。如果没有这个字段，那么 body 就是不定长的，需要使用 chunked 方式分段传输


----------------------------------------------

### 请求方法

它的实际含义就是客户端发出了一个动作指令，要求服务器端对 URI 定位的资源执行这个动作

目前 HTTP/1.1 规定了八种方法，单词都必须是大写的形式：
- GET：获取资源，可以理解为读取或者下载数据
- HEAD：获取资源的元信息
- POST：向资源提交数据，相当于写入或上传数据
- PUT：类似 POST
- DELETE：删除资源
- CONNECT：建立特殊的连接隧道
- OPTIONS：列出可对资源实行的方法
- TRACE：追踪请求 - 响应的传输路径

#### GET/HEAD

它的含义是请求从服务器获取资源，这个资源既可以是静态的文本、页面、图片、视频，也可以是由 PHP、Java 动态生成的页面或者其他格式的数据

`GET` 方法虽然基本动作比较简单，但搭配 URI 和其他头字段就能实现对资源更精细的操作, 例如，在 URI 后使用`#`，就可以在获取页面后直接定位到某个标签所在的位置；使用 `If-Modified-Since` 字段就变成了`有条件的请求`，仅当资源被修改时才会执行获取动作；使用 Range 字段就是`范围请求`，只获取资源的一部分数据

HEAD 方法与 GET 方法类似，也是请求从服务器获取资源，服务器的处理机制也是一样的，但服务器不会返回请求的实体数据，只会传回响应头，也就是资源的元信息, HEAD 方法可以看做是 GET 方法的一个简化版。因为它的响应头与 GET 完全相同，所以可以用在很多并不真正需要资源的场合，避免传输 body 数据的浪费. 比如，想要检查一个文件是否存在，只要发个 HEAD 请求就可以了，没有必要用 GET 把整个文件都取下来。再比如，要检查文件是否有最新版本，同样也应该用 HEAD，服务器会在响应头里把文件的修改时间传回来

#### POST/PUT

GET 和 HEAD 方法是从服务器获取数据，而 POST 和 PUT 方法则是相反操作，向 URI 指定的资源提交数据，数据就放在报文的 body 里

比如，你上论坛灌水，敲了一堆字后点击发帖按钮，浏览器就执行了一次 POST 请求，把你的文字放进报文的 body 里，然后拼好 POST 请求头，通过 TCP 协议发给服务器

在实际应用中，PUT 用到的比较少。而且，因为它与 POST 的语义、功能太过近似，有的服务器甚至就直接禁止使用 PUT 方法，只用 POST 方法上传数据


#### 其他方法

`DELETE` 方法指示服务器删除资源，因为这个动作危险性太大，所以通常服务器不会执行真正的删除操作，而是对资源做一个删除标记。当然，更多的时候服务器就直接不处理 `DELETE` 请求

`CONNECT` 是一个比较特殊的方法，要求服务器为客户端和另一台远程服务器建立一条特殊的连接隧道，这时 Web 服务器在中间充当了代理的角色

`OPTIONS` 方法要求服务器列出可对资源实行的操作方法，在响应头的 Allow 字段里返回。它的功能很有限，用处也不大，有的服务器（例如 Nginx）干脆就没有实现对它的支持

`TRACE` 方法多用于对 HTTP 链路的测试或诊断，可以显示出请求 - 响应的传输路径。它的本意是好的，但存在漏洞，会泄漏网站的信息，所以 Web 服务器通常也是禁止使用

#### 安全与幂等

在 HTTP 协议里，所谓的**安全**是指请求方法不会破坏服务器上的资源，即不会对服务器上的资源造成实质的修改

按照这个定义，只有 GET 和 HEAD 方法是安全的，因为它们是只读操作，只要服务器不故意曲解请求方法的处理方式，无论 GET 和 HEAD 操作多少次，服务器上的数据都是安全的

而 POST/PUT/DELETE 操作会修改服务器上的资源，增加或删除数据，所以是不安全的

所谓的**幂等**实际上是一个数学用语，被借用到了 HTTP 协议里，意思是多次执行相同的操作，结果也都是相同的，即多次`幂`后结果相等

GET 和 HEAD 既是安全的也是幂等的，DELETE 可以多次删除同一个资源，效果都是资源不存在，所以也是幂等的

POST 是新增或提交数据，多次提交数据会创建多个资源，所以不是幂等的；而 PUT 是替换或更新数据，多次更新一个资源，资源还是会第一次更新的状态，所以是幂等的

-----------------------------------------

### 正确的网址

#### 用什么来标记服务器上的资源呢？

用的是 URI，也就是统一资源标识符（Uniform Resource Identifier）。因为它经常出现在浏览器的地址栏里，简称网址

URI 不完全等同于网址，它包含有 `URL` 和 `URN` 两个部分，在 HTTP 世界里用的网址实际上是 URL——统一资源定位符（Uniform Resource Locator）。但因为 URL 实在是太普及了，所以常常把这两者简单地视为相等

#### URI 的格式

URI 本质上是一个字符串，这个字符串的作用是唯一地标记资源的位置或者名字

URI 最常用的形式，由 scheme、host:port、path 和 query 四个部分组成，但有的部分可以视情况省略

`scheme://` + `host:port` + `path` + `?query`

#### URI 的基本组成

URI 第一个组成部分叫 scheme，翻译成中文叫协议名，表示资源应该使用哪种协议来访问

最常见的当然就是http了，表示使用 HTTP 协议。另外还有https，表示使用经过加密、安全的 HTTPS 协议。此外还有其他不是很常见的 scheme，例如 ftp、ldap、file、news 等

