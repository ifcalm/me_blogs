## 链表解题

如果说数据结构是算法的基础，那么数组和链表就是数据结构的基础。 因为像堆，栈，树，图等比较复杂的数组结基本上都可以由数组和链表来表示，所以掌握数组和链表的基本操作十分重要

### 链表的定义

链表是物理存储单元上非连续的、非顺序的存储结构，它是由一个个结点，通过指针来联系起来的，其中每个结点包括数据和指针

链表的非连续，非顺序，对应数组的连续，顺序

结点都分配在非连续的位置，结点与结点之间通过指针连在了一起，所以如果我们要找比如值为 3  的结点时，只能通过头结点从头到尾遍历寻找，如果元素少还好，如果元素太多，每个元素的查找都要从头开始查找，时间复杂度是`O(n)`，比起数组的 `O(1)`，差距不小

除了查找性能链表不如数组外，还有一个优势让数组的性能高于链表,这里引入**程序局部性原理**

**CPU 运行速度是非常快的，如果 CPU 每次运算都要到内存里去取数据无疑是很耗时的，所以在 CPU 与内存之间往往集成了挺多层级的缓存，这些缓存越接近CPU，速度越快，所以如果能提前把内存中的数据加载缓存中，那么下一次 CPU 取数的话直接从这些缓存里取即可，能让CPU执行速度加快，那什么情况下内存中的数据会被提前加载到缓存中呢，答案是当某个元素被用到的时候，那么这个元素地址附近的的元素会被提前加载到缓存中**

当程序用到了数组中的第一个元素时，由于 CPU 认为既然 1 被用到了，那么紧邻它的元素 2，3，4 被用到的概率会很大，所以会提前把 2，3，4 加到缓存中去，这样 CPU 再次执行的时候如果用到 2，3，4，直接从缓存里取就行了，能提升不少性能

而链表由于的每个结点在内存里都是随机分布的，只是通过指针联系在一起，所以这些结点的地址并不相邻，自然无法利用 程序局部性原理 来提前加载到缓存中来提升程序性能

### 链表的使用场景

- 由于数组空间的连续性，如果要为数组分配 500M 的空间，这 500M 的空间必须是连续的，未使用的，所以在内存空间的分配上数组的要求会比较严格，如果内存碎片太多，分配连续的大空间很可能导致失败。而链表由于是非连续的，所以这种情况下选择链表更合适
- 如果涉及到元素的频繁删除和插入，用链表就会高效很多，对于数组来说，如果要在元素间插入一个元素，需要把其余元素一个个往后移，以为新元素腾空间，同理，如果是删除则需要把被删除元素之后的元素一个个往前移，效率上无疑是比较低的

**即如果数据以查为主，很少涉及到增和删，选择数组，如果数据涉及到频繁的插入和删除，或元素所需分配空间过大，倾向于选择链表**


### 链表的表示

由于链表的特点, 查询或删除元素都要从头结点开始, 所以我们只要在链表中定义头结点即可,另外如果要频繁用到链表的长度，还可以额外定义一个变量来表示

```
//链表中的节点数据，包含一个数据域，一个指针域，指向下一个节点
type Node struct {
    Data interface{}
    Next *Node
}

//链表，包含链表的头指针和链表的长度
type List struct {
    Head *Node
    Length int
}

//创建一个节点
func CreateNode(v interface{}) *Node {
    return &Node{v, nil}
}

//创建一个链表
func CreateList() *List {
    head := CreateNode(nil)
    return &List{head, 0}
}

//往链表头增加一个节点
func (l *List) AddNode(data interface{}) {
    newNode := CreateNode(data)
    //链表长度+1
    defer func() {
        l.Length++
    }()

    //设置新的头节点
    if l.Length == 0 {
        l.Head = newNode
    } else {
        newNode.Next = l.Head
        l.Head = newNode
    }
}

//往链表尾加一个节点
func (l *List) AppendNode(data interface{}) {
    newNode := CreateNode(data)
    //链表长度+1
    defer func() {
        l.Length++
    }()

    if l.Length == 0 {
        l.Head = newNode
    } else {
        current := l.Head
        for current.Next != nil {  //循环找到最后一个节点
            current = current.Next
        }
        current.Next = newNode   //把新节点地址赋给最后一个节点的Next
    }
}
```

### 链表常见解题技巧

我们要用链表解题，首先需要构造一个链表

*给定单向链表的头指针和一个节点指针，定义一个函数在 O(1) 内删除这个节点*

我们知道，如果给定一个结点要删除它的后继结点是很简单的，只要把这个结点的指针指向后继结点的后继结点即可 `p.Next = p.Next.Next`

但是怎么删除结点本身呢，注意题目没有规定说不能改变结点中的值，所以有一种很巧妙的方法，我们先通过结点 2 找到结点 3，再把节点 3 的值赋给结点 2，此时结点 2 的值变成了 3，即 `p = p.Next`

不过需要注意的是这种解题技巧只适用于被删除的指定结点是中间结点的情况，如果指定结点是尾结点，还是要老老实实地找到尾结点的前继结点，再把尾结点删除

```
//删除第 i 个节点
func (l *List) Delete(i int) {
    defer func() {
        l.Length--
    }

    //删除第一个节点，把head指向第二个节点即可
    if i == 1 {
        l.Head = l.Head.Next
    }

    //找到第 i-1 位置的节点, 找到第 i+1 位置的节点, 修改 i-1 节点的Next即可
    current := l.Head
    j := 0
    for j != i-1 {
        current = current.Next
        j++
    }
    after := current.Next.Next
    current.Next = after
}
```

### 链表翻转

什么是链表的翻转: 给定链表 `head–>4—>3–>2–>1`，将其翻转成 `head–>1–>2–>3–>4`

链表翻转是非常常见的，有**递归和非递归解法**

#### 递归翻转

首先我们要查看翻转链表是否符合**递归规律**：问题可以分解成具有相同解决思路的子问题，子子问题，直到最终的子问题再也无法分解

要翻转 `head—>4—>3–>2–>1` 链表，不考虑 head 结点，分析 `4—>3–>2–>1`，仔细观察我们发现只要先把 `3–>2–>1` 翻转成 `3<—-2<—-1`，之后再把 3 指向 4 即可

**由于子问题与最初的问题具有相同的解决思路，拆分后的子问题持续调用这个翻转函数即可达到目的**

*1.定义递归函数，明确函数的功能，这个递归函数的功能显然是翻转某个节点开始的链表，然后返回新的头结点*

```
func invertLinkedList(head *Node) *Node {

}
```

*2.寻找递推公式*

针对结点 node, 先翻转 node 之后的结点, 再把 node 节点的下个节点指向 node, 返回新的头结点

*3.将递推公式代入第一步定义好的函数中*

```
func invertLinkedList(head *Node) *Node {
    if head.Next == nil {
        return head
    }

    // 步骤 1: 先翻转 node 之后的链表
    newHead := invertLinkedList(head.Next)

    // 步骤 2: 再把原 node 节点后继结点的后继结点指向 node，node 的后继节点设置为空, 防止形成环
    head.Next.Next = head
    head.Next = nil

    //返回翻转后的头结点return newHead
    return newHead
}
```

*4.计算时间/空间复杂度 由于递归调用了 n 次 invertLinkedList 函数，所以时间复杂度显然是 O(n), 空间复杂度呢，没有用到额外的空间，但是由于递归调用了  n 次 invertLinkedList 函数，压了 n 次栈，所以空间复杂度也是 O(n)*


**递归一定要从函数的功能去理解，从函数的功能看，定义的递归函数清晰易懂，定义好了之后，由于问题与被拆分的子问题具有相同的解决思路，所以子问题只要持续调用定义好的功能函数即可，切勿层层展开子问题，这是递归常见的陷阱**

#### 非递归翻转---迭代解法

我们知道递归比较容易造成栈溢出，所以如果有其他时间/空间复杂度相近或更好的算法，应该优先选择非递归的解法

- 1.定义两个节点：pre, cur ，其中 cur 是 pre 的后继结点，如果是首次定义， 需要把 pre 指向 cur 的指针去掉，否则由于之后链表翻转，cur 会指向 pre
- 知道了 cur 和 pre,翻转就容易了，把 cur 指向 pre 即可，之后把 cur 设置为 pre ，cur 的后继结点设置为 cur 一直往前重复此步骤即可

```
func invertLinkedList(head *Node) *Node {
    pre := head.Next
    cur := pre.Next
    pre.Next = nil
    for cur != nil {
        //在 cur 指向 pre 之前一定要先保留 cur 的后继结点，不然 cur 指向 pre 后就再也找不到后继结点了
        next := cur.Next
        cur.Next = pre
        pre = cur
        cur = next
    }
    head.Next = pre
    return head
}
```

用迭代的思路来做由于循环了 n 次，显然时间复杂度为 `O(n)`, 另外由于没有额外的空间使用，也未像递归那样调用递归函数不断压栈，所以空间复杂度是 `O(1)`,对比递归，显然应该使用迭代的方式来处理

