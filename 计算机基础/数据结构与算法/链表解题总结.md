## 链表解题

如果说数据结构是算法的基础，那么数组和链表就是数据结构的基础。 因为像堆，栈，树，图等比较复杂的数组结基本上都可以由数组和链表来表示，所以掌握数组和链表的基本操作十分重要

### 链表的定义

链表是物理存储单元上非连续的、非顺序的存储结构，它是由一个个结点，通过指针来联系起来的，其中每个结点包括数据和指针

链表的非连续，非顺序，对应数组的连续，顺序

结点都分配在非连续的位置，结点与结点之间通过指针连在了一起，所以如果我们要找比如值为 3  的结点时，只能通过头结点从头到尾遍历寻找，如果元素少还好，如果元素太多，每个元素的查找都要从头开始查找，时间复杂度是`O(n)`，比起数组的 `O(1)`，差距不小

除了查找性能链表不如数组外，还有一个优势让数组的性能高于链表,这里引入**程序局部性原理**

**CPU 运行速度是非常快的，如果 CPU 每次运算都要到内存里去取数据无疑是很耗时的，所以在 CPU 与内存之间往往集成了挺多层级的缓存，这些缓存越接近CPU，速度越快，所以如果能提前把内存中的数据加载缓存中，那么下一次 CPU 取数的话直接从这些缓存里取即可，能让CPU执行速度加快，那什么情况下内存中的数据会被提前加载到缓存中呢，答案是当某个元素被用到的时候，那么这个元素地址附近的的元素会被提前加载到缓存中**

当程序用到了数组中的第一个元素时，由于 CPU 认为既然 1 被用到了，那么紧邻它的元素 2，3，4 被用到的概率会很大，所以会提前把 2，3，4 加到缓存中去，这样 CPU 再次执行的时候如果用到 2，3，4，直接从缓存里取就行了，能提升不少性能

而链表由于的每个结点在内存里都是随机分布的，只是通过指针联系在一起，所以这些结点的地址并不相邻，自然无法利用 程序局部性原理 来提前加载到缓存中来提升程序性能

### 链表的使用场景

- 由于数组空间的连续性，如果要为数组分配 500M 的空间，这 500M 的空间必须是连续的，未使用的，所以在内存空间的分配上数组的要求会比较严格，如果内存碎片太多，分配连续的大空间很可能导致失败。而链表由于是非连续的，所以这种情况下选择链表更合适
- 如果涉及到元素的频繁删除和插入，用链表就会高效很多，对于数组来说，如果要在元素间插入一个元素，需要把其余元素一个个往后移，以为新元素腾空间，同理，如果是删除则需要把被删除元素之后的元素一个个往前移，效率上无疑是比较低的

**即如果数据以查为主，很少涉及到增和删，选择数组，如果数据涉及到频繁的插入和删除，或元素所需分配空间过大，倾向于选择链表**


### 链表的表示

由于链表的特点, 查询或删除元素都要从头结点开始, 所以我们只要在链表中定义头结点即可,另外如果要频繁用到链表的长度，还可以额外定义一个变量来表示

```
//链表中的节点数据，包含一个数据域，一个指针域，指向下一个节点
type Node struct {
    Data interface{}
    Next *Node
}

//链表，包含链表的头指针和链表的长度
type List struct {
    Head *Node
    Length int
}

//创建一个节点
func CreateNode(v interface{}) *Node {
    return &Node{v, nil}
}

//创建一个链表
func CreateList() *List {
    head := CreateNode(nil)
    return &List{head, 0}
}

//往链表头增加一个节点
func (l *List) AddNode(data interface{}) {
    newNode := CreateNode(data)
    //链表长度+1
    defer func() {
        l.Length++
    }()

    //设置新的头节点
    if l.Length == 0 {
        l.Head = newNode
    } else {
        newNode.Next = l.Head
        l.Head = newNode
    }
}

//往链表尾加一个节点
func (l *List) AppendNode(data interface{}) {
    newNode := CreateNode(data)
    //链表长度+1
    defer func() {
        l.Length++
    }()

    if l.Length == 0 {
        l.Head = newNode
    } else {
        current := l.Head
        for current.Next != nil {  //循环找到最后一个节点
            current = current.Next
        }
        current.Next = newNode   //把新节点地址赋给最后一个节点的Next
    }
}
```

