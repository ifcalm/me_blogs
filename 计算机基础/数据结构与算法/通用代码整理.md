## 常用算法代码整理

### go 常用片段

#### go 通过切片模拟栈和队列

*栈操作*
```
//创建栈
stack := make([]int, 0)

//push压入
stack = append(stack, 10)

//pop 弹出
val := stack[len(stack)-1]
stack = stack[:len(stack)-1]

//检查栈空
len(stack) == 0
```

*队列操作*
```
//创建队列
queue := make([]int, 0)

//入队
queue = append(queue, 10)

//出队
val := queue[0]
queue = queue[1:]

//判断队为空
len(queue) == 0
```

- `s = s[0:len(s)]`，取下限不取上限

#### 字典
```
//创建字典
m := make(map[string]int)

//设置k, v
m["test"] = 10

//删除k
delete(m, "test")

//遍历字典
for k, v := range m {
    fmt.Println(k, v)
}
```

- map 键需要可比较，不能为 slice、map、function
- map 值都有默认值，可以直接操作默认值，如：`m[age]++` 值由 0 变为 1
- 比较两个 map 需要遍历，其中的 kv 是否相同，因为有默认值关系，所以需要检查 val 和 ok 两个值

#### 常用标准库函数

*sort*
```
//int排序
sort.Ints([]int{})

//字符串排序
sort.Strings([]string{})

//自定义排序
sort.Slice(s, func(i, j int) bool {return s[i] < s[j]>})
```

*math*
```
math.MaxInt32
math.MinInt32

math.MaxInt64
math.MinInt64
```

*copy*
```
待补充
```

#### 类型转换

```
// byte转数字
s="12345"  // s[0] 类型是byte

num:=int(s[0]-'0') // 1
str:=string(s[0]) // "1"
b:=byte(num+'0') // '1'
fmt.Printf("%d%s%c\n", num, str, b) // 111

//字符串转数字
num,_:=strconv.Atoi()
str:=strconv.Itoa()
```

-------------------------------------

### 数据结构与算法

数据结构是一种数据的表现形式，如链表、二叉树、栈、队列等都是内存中一段数据表现的形式。 算法是一种通用的解决问题的模板或者思路，大部分数据结构都有一套通用的算法模板，所以掌握这些通用的算法模板即可解决各种算法问题

### 二叉树

#### 二叉树遍历

- 前序遍历: 先访问根节点，再前序遍历左子树，再前序遍历右子树
- 中序遍历: 先中序遍历左子树，再访问根节点，再中序遍历右子树
- 后序遍历: 先后序遍历左子树，再后序遍历右子树，再访问根节点

**以根访问顺序决定是什么遍历, 左子树都是优先右子树**


##### 前序递归
```
func preorderTraversal(root *TreeNode) {
    if root == nil {
        return
    }
    //先访问根再访问左右
    fmt.Println(root.Val)
    preorderTraversal(root.Left)
    preorderTraversal(root.Right)
}
```

##### 前序非递归
```
func preorderTraversal(root *TreeNode) []int {
    if root == nil {
        return nil
    }
    result := make([]int, 0)
    stack := make([]*TreeNode, 0)

    for root != nil || len(stack) != 0 {
        for root != nil {
            //前序遍历，先保存结果
            result = append(result, root.Val)
            stack = append(stack, root)
            root = root.Left
        }
        //pop操作
        node := stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        root = node.Right
    }
    return result
}
```

##### 中序非递归
```
//通过stack 保存已经访问的元素，用于原路返回
func inorderTraversal(root *TreeNode) []int {
    if root == nil {
        return nil
    }
    result := make([]int, 0)
    stack := make([]*TreeNode, 0)

    for len(stack) > 0 || root != nil {
        for root != nil {
            stack = append(stack, root)
            root = root.Left
        }
        //弹出操作
        node := stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        result = append(result, node.Val)
        root = node.Right
    }
    return result
}
```

##### 后序非递归
```
func postorderTraversal(root *TreeNode) []int {
    if root == nil {
        return nil
    }
    result := make([]int, 0)
    stack := make([]*TreeNode, 0)
    //通过lastVisit标识右子节点是否已经弹出
    var lastVisit *TreeNode

    for root != nil || len(stack) != 0 {
        for root != nil {
            stack = append(stack, root)
            root = root.Left
        }
        //这里先看看，先不弹出
        node := stack[len(stack)-1]
        // 根节点必须在右节点弹出之后，再弹出
        if node.Right == nil || node.Right == lastVist {
            //弹出
            stack = stack[:len(stack)-1]
            result = append(result, node.Val)
            //标记当前这个节点已经弹出过
            lastVisit = node
        } else {
            root = node.Right
        }
    }
    return result
}
```

#### DFS 深度搜索-从上到下

```
type TreeNode struct {
    Val int
    Left *TreeNode
    Right *TreeNode
}

func preorderTraversal(root *TreeNode) []int {
    result := make([]int, 0)
    dfs(root, &result)
    return result
}

//深度遍历，结果指针作为参数传入到函数内部
func dfs(root *TreeNode, result *[]int) {
    if root == nil {
        return
    }

    *result = append(*result, root.Val)
    dfs(root.Left, result)
    dfs(root.Right, result)
}
```

#### DFS 深度搜索-从下向上（分治法）
```
func preorderTraversal(root *TreeNode) []int {
    result := divideAndConquer(root)
    return result
}

//通过分治法遍历
func divideAndConquer(root *TreeNode) []int {
    result := make([]int, 0)
    if root == nil {
        return result
    }

    //分治(Divide)
    left := divideAndConquer(root.Left)
    right := divideAndConquer(root.Right)

    //合并结果(Conquer)
    result = append(result, root.Val)
    result = append(result, left...)
    result = append(result, right...)
    return result
}
```

#### BFS 层次遍历

```
func levelOrder(root *TreeNode) [][]int {
    if root == nil {
        return nil
    }
    result := make([][]int, 0)
    queue := make([]*TreeNode, 0)
    queue = append(queue, root)

    for len(queue)>0 {
        list := make([]int, 0)
        //为什么要取length？
        //记录当前层有多少元素（遍历当前层，再添加下一层）
        l := len(queue)

        for i := 0; i < l; i++ {
            //出队
            level := queue[0]
            queue = queue[1:]
            list = append(list, level.Val)
            if level.Left != nil {
                queue = append(queue, level.Left)
            }
            if level.Right != nil {
                queue = append(queue, level.Right)
            }
        }
        result = append(result, list)
    }
    return result
}
```

#### 分治法的应用

先分别处理局部，再合并结果

- 快速排序
- 归并排序
- 二叉树相关问题

分治法解题模板：
- 递归返回条件
- 分段处理
- 合并结果

##### 归并排序

```
func MergeSort(nums []int) []int {
    return mergeSort(nums)
}

func mergeSort(nums []int) []int {
    if len(nums) <= 1 {
        return nums
    }

    //分治法：divide 分为两段
    mid := len(nums)/2
    left := mergeSort(nums[:mid])
    right := mergeSort(nums[mid:])

    //合并两段数据
    result := merge(left, right)
    return result
}

func merge(left, right []int) (result []int) {
    // 两边数组合并游标
    l := 0
    r := 0

    // 注意不能越界
    for l < len(left) && r < len(right) {
        if left[l] > right[r] {
            result = append(result, right[r])
            r++
        } else {
            result = append(result, left[l])
            l++
        }
    }
    // 剩余部分合并
    result = append(result, left[l:]...)
    result = append(result, right[r:]...)
    return
}
```

#### 快速排序

```
func QuickSort(nums []int) []int {
    // 思路：把一个数组分为左右两段，左段小于右段，类似分治法没有合并过程
    quickSort(nums, 0, len(nums)-1)
    return nums
}

// 原地交换，所以传入交换索引
func quickSort(nums []int, start, end int) {
    if start < end {
        // 分治法：divide
        pivot := partition(nums, start, end)
        quickSort(nums, 0, pivot-1)
        quickSort(nums, pivot+1, end)
    }
}

// 分区
func partition(nums []int, start, end int) int {
    p := nums[end]
    i := start
    for j := start; j < end; j++ {
        if nums[j] < p {
            swap(nums, i, j)
            i++
        }
    }
    // 把中间的值换为用于比较的基准值
    swap(nums, i, end)
    return i
}

func swap(nums []int, i, j int) {
    t := nums[i]
    nums[i] = nums[j]
    nums[j] = t
}
```

### 链表

需要重点掌握的一些链表操作:

- nil 异常处理
- 设置哑巴节点
- 快慢指针
- 插入一个节点到排序链表
- 从一个链表中移除一个节点
- 翻转链表
- 合并两个链表
- 找到链表的中间节点


#### 代码示例:

待补充


### 栈和队列

栈的特点是后入先出, 根据这个特点可以临时保存一些数据，之后用到依次再弹出来，常用于 DFS 深度搜索, 队列一般常用于 BFS 广度搜索，类似一层一层的搜索

#### 代码示例

待补充


### 二进制

#### 代码示例

待补充


### 二分搜索

