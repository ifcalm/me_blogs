## 什么是数据结构
数据存储于内存时，决定了数据顺序和位置关系的便是`数据结构`,即数据的存储和排列方式

将数据存储于内存时，根据使用目的选择合适的数据结构，可以提高内存的利用率


## 链表
链表是数据结构之一，其中的数据呈线性排列。在链表中，数据的添加和删除都较为方便，就是访问比较耗费时间

链表每个数据都有1个`指针`，它指向下一个数据的内存地址

在链表中，数据一般都是分散存储于内存中的，无须存储在连续空间内

因为数据都是分散存储的，所以如果想要访问数据，只能从第1个数据开始，顺着指针的指向一一往下访问,这便是顺序访问

如果想要添加数据，只需要改变添加位置前后的指针指向就可以,数据的删除也一样，只要改变指针的指向就可以

对链表的操作所需的运行时间到底是多少呢？在这里，我们把链表中的数据量记成`n`。访问数据时，我们需要从链表头部开始查找（线性查找），如果目标数据在链表最后的话，需要的时间就是`O（n）`。

另外，添加数据只需要更改两个指针的指向，所以耗费的时间与`n`无关。如果已经到达了添加数据的位置，那么添加操作只需花费`O（1）`的时间。删除数据同样也只需`O（1）`的时间。

们也可以在链表尾部使用指针，并且让它指向链表头部的数据，将链表变成环形。这便是`循环链表`，也叫`环形链表`。循环链表没有头和尾的概念。想要保存数量固定的最新数据时通常会使用这种链表

我们可以把指针设定为两个，并且让它们分别指向前后数据，这就是`双向链表`。使用这种链表，不仅可以从前往后，还可以从后往前遍历数据

双向链表存在两个缺点:
- 指针数的增加会导致存储空间需求增加
- 添加和删除数据时需要改变更多指针的指向


## 数组
数组也是数据呈线性排列的一种数据结构,在数组中，访问数据十分简单，而添加和删除数据比较耗工夫

数组中的数据按顺序存储在内存的连续空间内

由于数据是存储在连续空间内的，所以每个数据的内存地址都可以通过数组下标算出，我们也就可以借此直接访问目标数据,这叫作`随机访问`

如果想在任意位置上添加或者删除数据，数组的操作就要比链表复杂多了

*在链表和数组中，数据都是线性地排成一列。在链表中访问数据较为复杂，添加和删除数据较为简单；而在数组中访问数据比较简单，添加和删除数据却比较复杂*


## 栈
栈也是一种数据呈线性排列的数据结构，不过在这种结构中，我们只能访问最新添加的数据。栈就像是一摞书，拿到新书时我们会把它放在书堆的最上面，取书时也只能从最上面的新书开始取

栈的两种操作:
- 入栈
- 出栈

从栈中取出数据时，是从最上面，也就是最新的数据开始取出的

与链表和数组一样，栈的数据也是线性排列，但在栈中，添加和删除数据的操作只能在一端进行，访问数据也只能访问到顶端的数据。想要访问中间的数据时，就必须通过出栈操作将目标数据移到栈顶才行

## 队列
队列中的数据也呈线性排列。虽然与栈有些相似，但队列中添加和删除数据的操作分别是在两端进行的。就和`队列`这个名字一样，把它想象成排成一队的人更容易理解。在队列中，处理总是从第一名开始往后进行，而新来的人只能排在队尾

- 入队
- 出队

与栈类似，队列中可以操作数据的位置也有一定的限制。在栈中，数据的添加和删除都在同一端进行，而在队列中则分别是在两端进行的。队列也不能直接访问位于中间的数据，必须通过出队操作将目标数据变成首位后才能访问


## 哈希表
哈希表存储的是由键`key`和值`value`组成的数据。例如，我们将每个人的性别作为数据进行存储，键为人名，值为对应的性别

在哈希表中，我们可以利用哈希函数快速访问到数组中的目标数据。如果发生哈希冲突，就使用`链表`进行存储。这样一来，不管数据量为多少，我们都能够灵活应对。

如果数组的空间太小，使用哈希表的时候就容易发生冲突，线性查找的使用频率也会更高；反过来，如果数组的空间太大，就会出现很多空箱子，造成内存的浪费。因此，给数组设定合适的空间非常重要


在存储数据的过程中，如果发生冲突，可以利用链表在已有数据的后面插入新数据来解决冲突。这种方法被称为`链地址法`

除了链地址法以外，还有几种解决冲突的方法。其中，应用较为广泛的是`开放地址法`。这种方法是指当冲突发生时，立刻计算出一个候补地址（数组上的位置）并将数据存进去。如果仍然有冲突，便继续计算下一个候补地址，直到有空地址为止。可以通过多次使用`哈希函数`或`线性探测法`等方法计算候补地址


## 堆
堆是一种图的树形结构，被用于实现`优先队列`,优先队列是一种数据结构，可以自由添加数据，但取出数据时要从最小值开始按顺序取出。在堆的树形结构中，各个顶点被称为`结点`（node），数据就存储在这些结点中

堆中的每个结点最多有两个子结点,结点的排列顺序为从上到下，同一行里则为从左到右

在堆中存储数据时必须遵守这样一条规则：子结点必定大于父结点。因此，最小值被存储在顶端的根结点中。往堆中添加数据时，为了遵守这条规则，一般会把新数据放在最下面一行靠左的位置。当最下面一行里没有多余空间时，就再往下另起一行，把数据加在这一行的最左端

如果父结点大于子结点，则不符合规则，因此需要交换父子结点的位置,重复这样的操作直到数据都符合规则，不再需要交换为止

从堆中取出数据时，取出的是最上面的数据。这样，堆中就能始终保持最上面的数据最小,由于最上面的数据被取出，因此堆的结构也需要重新调整

堆中最顶端的数据始终最小，所以无论数据量有多少，取出最小值的时间复杂度都为`O（1）`

另外，因为取出数据后需要将最后的数据移到最顶端，然后一边比较它与子结点数据的大小，一边往下移动，所以取出数据需要的运行时间和树的高度成正比。假设数据量为`n`，根据堆的形状特点可知树的高度为`log2n`，那么重构树的时间复杂度便为`O（logn）`

添加数据也一样。在堆的最后添加数据后，数据会一边比较它与父结点数据的大小，一边往上移动，直到满足堆的条件为止，所以添加数据需要的运行时间与树的高度成正比，也是`O（logn）`


## 二叉查找树
二叉查找树,又叫作二叉搜索树或二叉排序树,是一种数据结构，采用了图的树形结构,数据存储于二叉查找树的各个结点中

二叉查找树有两个性质:
- 每个结点的值均大于其左子树上任意一个结点的值
- 每个结点的值均小于其右子树上任意一个结点的值

根据这两个性质可以得到以下结论:
- 二叉查找树的最小结点要从顶端开始，往其左下的末端寻找
- 二叉查找树的最大结点要从顶端开始，往其右下的末端寻找

插入或删除节点数据后，需要调整数据以满足规则


------------------------------------------------

## 排序

排序就是将输入的数字按照从小到大的顺序进行排列

## 冒泡排序
冒泡排序就是重复`从序列左边开始比较相邻两个数字的大小，再根据结果交换两个数字的位置`这一操作的算法。在这个过程中，数字会像泡泡一样，慢慢从左往右浮到序列的顶端，所以这个算法才被称为`冒泡排序`

```
[2, 4, 1, 5, 8, 3]

先比较索引为 0 与 1 的值，在比较索引 1 与 2 的值，重复这个过程，直到结束
```

在冒泡排序中，第1轮需要比较`n-1`次，第2轮需要比较`n-2`次……第`n-1`轮需要比较1次。因此，总的比较次数为`（n-1）+（n-2）+…+1≈n2/2`。这个比较次数恒定为该数值，和输入数据的排列顺序无关。

不过，交换数字的次数和输入数据的排列顺序有关。假设出现某种极端情况，如输入数据正好以从小到大的顺序排列，那么便不需要任何交换操作；反过来，输入数据要是以从大到小的顺序排列，那么每次比较数字后便都要进行交换。因此，冒泡排序的时间复杂度为`O（n2）`

## 选择排序
选择排序就是重复`从待排序的数据中寻找最小值，将其与待排序列最左边的数字进行交换`这一操作的算法。在序列中寻找最小值时使用的是线性查找

选择排序使用了线性查找来寻找最小值，因此在第1轮中需要比较`n-1`个数字，第2轮需要比较`n-2`个数字……到第`n-1`轮的时候就只需比较1个数字了。

因此，总的比较次数与冒泡排序的相同，都是`（n-1）+（n-2）+…+1≈n2/2`次。每轮中交换数字的次数最多为1次。如果输入数据就是按从小到大的顺序排列的，便不需要进行任何交换。选择排序的时间复杂度也和冒泡排序的一样，都为`O（n2）`


## 插入排序
插入排序是一种从序列左端开始依次对数据进行排序的算法。在排序过程中，左侧的数据陆续归位，而右侧留下的就是还未被排序的数据。插入排序的思路就是从右侧的未排序区域内取出一个数据，然后将它插入到已排序区域内合适的位置上

在插入排序中，需要将取出的数据与其左边的数字进行比较。就跟前面讲的步骤一样，如果左边的数字更小，就不需要继续比较，本轮操作到此结束，自然也不需要交换数字的位置

然而，如果取出的数字比左边已归位的数字都要小，就必须不停地比较大小，交换数字，直到它到达整个序列的最左边为止。具体来说，就是第k轮需要比较`k-1`次。因此，在最糟糕的情况下，第2轮需要操作1次，第3轮操作2次……第n轮操作n-1次，所以时间复杂度和冒泡排序的一样，都为`O（n2）`

和前面讲的排序算法一样，输入数据按从大到小的顺序排列时就是最糟糕的情况

## 堆排序
堆排序的特点是利用了数据结构中的堆

堆排序一开始需要将n个数据存进堆里，所需时间为`O（nlogn）`。排序过程中，堆从空堆的状态开始，逐渐被数据填满。由于堆的高度小于`log2n`，所以插入1个数据所需要的时间为`O（logn）`。

每轮取出最大的数据并重构堆所需要的时间为`O（logn）`。由于总共有n轮，所以重构后排序的时间也是`O（nlogn）`。因此，整体来看堆排序的时间复杂度为`O（nlogn）`。

这样来看，堆排序的运行时间比之前讲到的冒泡排序、选择排序、插入排序的时间`O（n2）`都要短，但由于要使用堆这个相对复杂的数据结构，所以实现起来也较为困难

## 归并排序
归并排序算法会把序列分成长度相同的两个子序列，当无法继续往下分时,也就是每个子序列中只有一个数据时，就对子序列进行归并。归并指的是把两个排好序的子序列合并成一个有序序列。该操作会一直重复执行，直到所有子序列都归并为一个整体为止

## 快速排序
快速排序算法首先会在序列中随机选择一个基准值（pivot），然后将除了基准值以外的数分为“比基准值小的数”和“比基准值大的数”这两个类别，再将其排列成以下形式。

`[比基准值小的数] 基准值 [比基准值大的数]`

接着，对两个`[ ]` 中的数据进行排序之后，整体的排序便完成了。对`[ ]`里面的数据进行排序时同样也会使用快速排序

快速排序是一种`分治法`。它将原本的问题分成两个子问题,比基准值小的数和比基准值大的数，然后再分别解决这两个问题。子问题，也就是子序列完成排序后，再像一开始说明的那样，把他们合并成一个序列，那么对原始序列的排序也就完成了

不过，解决子问题的时候会再次使用快速排序，甚至在这个快速排序里仍然要使用快速排序。只有在子问题里只剩一个数字的时候，排序才算完成

像这样，在算法内部继续使用该算法的现象被称为`递归`


-------------------------------

