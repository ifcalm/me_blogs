如果能够充分掌握算法的一些技巧，能够混合运用起来，那么写出来的代码，必然非常优雅

### 多思考能否使用位运算

如果你现在去找个 IDE 写个代码测试下 `n / 2` 和 `n >> 1` 的运行效率，可能会发现没啥差别，其实并非没有差别，而是大部分编译器会自动帮你把 `n / 2` 优化成 `n >> 1`

### 异或运算的妙用

关于异或的特性:

- 两个相同的数相互异或，运算结果为 0，例如 `n ^ n = 0`
- 任何数和 0 异或，运算结果不变，例如 `n ^ 0 = n`
- 支持交换律和结合律，例如 `x ^ ( y ^ x) = (x ^ y) ^ x`

### 考虑是否可以使用数组下标

数组的下标是一个隐含的很有用的数组，特别是在统计一些数字，或者判断一些整型数是否出现过的时候

### 考虑能否使用双指针

双指针这个技巧，就更加常用的，特别是在链表和有序数组中

- 快慢指针, 两个指针从同一侧开始遍历数组，将这两个指针分别定义为快指针和慢指针，两个指针以不同的策略移动，直到两个指针的值相等或其他特殊条件为止，如快指针每次增长两个，慢指针每次增长一个
- 对撞指针, 是指在有序数组中，将指向最左侧的索引定义为左指针，最右侧的定义为右指针，然后从两头向中间进行数组遍历
- 滑动窗口法, 两个指针，一前一后组成滑动窗口，并计算滑动窗口中的元素的问题


### 从递归到备忘录到递推或者动态规划

递归非常好用，好多问题都可以使用递归来解决，不过大部分的的递归问题都可以进行剪枝，并且还有很多带有备忘录的递归都可以转化为动态规划

遇到递归的问题，一定要考虑是否可以剪枝，是否可以把递归转化成递推

1. 对于可以递归的问题务必考虑是否有重复计算的
   当我们使用递归来解决一个问题的时候，容易产生重复去算同一个子问题，这个时候我们要考虑状态保存以防止重复计算
2. 考虑自底向上
   对于递归的问题，我们一般都是从上往下递归的，直到递归到最底，再一层一层着把值返回, 当n比较大的时候，例如当 `n = 10000`时，那么必须要往下递归10000层直到 `n <=2` 才将结果慢慢返回，如果n太大的话，可能栈空间会不够用, 对于这种情况，其实我们是可以考虑自底向上的做法的, 我们也把这种自底向上的做法称之为递推

使用递归解决问题的时候，要考虑以下两个问题

- 是否有状态重复计算的，可不可以使用备忘录法来优化
- 是否可以采取递推的方法来自底向上做，减少一味递归的开销


### 考虑是否可以设置哨兵位来处理临界问题

在链表的相关问题中，我们经常会设置一个头指针，而且这个头指针是不存任何有效数据的，只是为了操作方便，这个头指针我们就可以称之为哨兵位了


###  动态规划解题

动态规划算法是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推或者说分治的方式去解决

动态规划需要明确掌握几个重要概念：

- 阶段，对于一个完整的问题过程，适当的切分为若干个相互联系的子问题，每次在求解一个子问题，则对应一个阶段，整个问题的求解转化为按照阶段次序去求解
- 状态，状态表示每个阶段开始时所处的客观条件，即在求解子问题时的已知条件。状态描述了研究的问题过程中的状况
- 决策，决策表示当求解过程处于某一阶段的某一状态时，可以根据当前条件作出不同的选择，从而确定下一个阶段的状态，这种选择称为决策
- 策略，由所有阶段的决策组成的决策序列称为全过程策略，简称策略
- 最优策略，在所有的策略中，找到代价最小，性能最优的策略，此策略称为最优策略
- 状态转移方程，状态转移方程是确定两个相邻阶段状态的演变过程，描述了状态之间是如何演变的


### 巧用取余

有时候我们在遍历数组的时候，会进行越界判断，如果下标差不多要越界了，我们就把它置为0重新遍历。特别是在一些环形的数组中，例如用数组实现的队列。往往会写出这样的代码：

```
for (int i = 0; i < N; i++) {
       if (pos < N) {
        //没有越界
        // 使用数组arr[pos]
        else {
          pos = 0;//置为0再使用数组
          //使用arr[pos]
         }
        pos++;
   }

```

实际上我们可以通过取余的方法来简化代码

```
for (int i = 0; i < N; i++) {
  //使用数组arr[pos]   (我们假设刚开始的时候pos < N)
  pos = (pos + 1) % N;
}
```

