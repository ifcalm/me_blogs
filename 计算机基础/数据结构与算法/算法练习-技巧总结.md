如果能够充分掌握算法的一些技巧，能够混合运用起来，那么写出来的代码，必然非常优雅

### 多思考能否使用位运算

如果你现在去找个 IDE 写个代码测试下 `n / 2` 和 `n >> 1` 的运行效率，可能会发现没啥差别，其实并非没有差别，而是大部分编译器会自动帮你把 `n / 2` 优化成 `n >> 1`

### 异或运算的妙用

关于异或的特性:

- 两个相同的数相互异或，运算结果为 0，例如 `n ^ n = 0`
- 任何数和 0 异或，运算结果不变，例如 `n ^ 0 = n`
- 支持交换律和结合律，例如 `x ^ ( y ^ x) = (x ^ y) ^ x`

### 考虑是否可以使用数组下标

数组的下标是一个隐含的很有用的数组，特别是在统计一些数字，或者判断一些整型数是否出现过的时候

### 考虑能否使用双指针

双指针这个技巧，就更加常用的，特别是在链表和有序数组中

- 快慢指针, 两个指针从同一侧开始遍历数组，将这两个指针分别定义为快指针和慢指针，两个指针以不同的策略移动，直到两个指针的值相等或其他特殊条件为止，如快指针每次增长两个，慢指针每次增长一个
- 对撞指针, 是指在有序数组中，将指向最左侧的索引定义为左指针，最右侧的定义为右指针，然后从两头向中间进行数组遍历
- 滑动窗口法, 两个指针，一前一后组成滑动窗口，并计算滑动窗口中的元素的问题


### 从递归到备忘录到递推或者动态规划

递归非常好用，好多问题都可以使用递归来解决，不过大部分的的递归问题都可以进行剪枝，并且还有很多带有备忘录的递归都可以转化为动态规划

遇到递归的问题，一定要考虑是否可以剪枝，是否可以把递归转化成递推

1. 对于可以递归的问题务必考虑是否有重复计算的
   当我们使用递归来解决一个问题的时候，容易产生重复去算同一个子问题，这个时候我们要考虑状态保存以防止重复计算
2. 考虑自底向上
   对于递归的问题，我们一般都是从上往下递归的，直到递归到最底，再一层一层着把值返回, 当n比较大的时候，例如当 `n = 10000`时，那么必须要往下递归10000层直到 `n <=2` 才将结果慢慢返回，如果n太大的话，可能栈空间会不够用, 对于这种情况，其实我们是可以考虑自底向上的做法的, 我们也把这种自底向上的做法称之为递推

使用递归解决问题的时候，要考虑以下两个问题

- 是否有状态重复计算的，可不可以使用备忘录法来优化
- 是否可以采取递推的方法来自底向上做，减少一味递归的开销


### 考虑是否可以设置哨兵位来处理临界问题

在链表的相关问题中，我们经常会设置一个头指针，而且这个头指针是不存任何有效数据的，只是为了操作方便，这个头指针我们就可以称之为哨兵位了


###  动态规划解题

动态规划算法是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推或者说分治的方式去解决

动态规划需要明确掌握几个重要概念：

- 阶段，对于一个完整的问题过程，适当的切分为若干个相互联系的子问题，每次在求解一个子问题，则对应一个阶段，整个问题的求解转化为按照阶段次序去求解
- 状态，状态表示每个阶段开始时所处的客观条件，即在求解子问题时的已知条件。状态描述了研究的问题过程中的状况
- 决策，决策表示当求解过程处于某一阶段的某一状态时，可以根据当前条件作出不同的选择，从而确定下一个阶段的状态，这种选择称为决策
- 策略，由所有阶段的决策组成的决策序列称为全过程策略，简称策略
- 最优策略，在所有的策略中，找到代价最小，性能最优的策略，此策略称为最优策略
- 状态转移方程，状态转移方程是确定两个相邻阶段状态的演变过程，描述了状态之间是如何演变的


### 巧用取余

有时候我们在遍历数组的时候，会进行越界判断，如果下标差不多要越界了，我们就把它置为0重新遍历。特别是在一些环形的数组中，例如用数组实现的队列。往往会写出这样的代码：

```
for (int i = 0; i < N; i++) {
       if (pos < N) {
        //没有越界
        // 使用数组arr[pos]
        else {
          pos = 0;//置为0再使用数组
          //使用arr[pos]
         }
        pos++;
   }

```

实际上我们可以通过取余的方法来简化代码

```
for (int i = 0; i < N; i++) {
  //使用数组arr[pos]   (我们假设刚开始的时候pos < N)
  pos = (pos + 1) % N;
}
```

### 字典表的运用

待补充

### 巧用移位运算

有时候我们在进行除数或乘数运算的时候，例如`n/2`，`n/4`, `n/8`这些运算的时候，我们就可以用移位的方法来运算了，这样会快很多

```
n/2 等价于 n>>1

n/4 等价于 n>>2

n/8 等价于 n>>3
```

### 递归优化问题

#### 对于可以递归的问题考虑状态保存

当我们使用递归来解决一个问题的时候，容易产生重复去算同一个子问题，这个时候我们要考虑状态保存以防止重复计算

*问题：* 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法？

这个问题用递归很好解决。假设 f(n) 表示n级台阶的总跳数法，则有 `f(n) = f(n-1) + f(n - 2)`, 递归的结束条件是当`0 <= n <= 2`时, f(n) = n。因此我们可以很容易写出递归的代码

不过对于可以使用递归解决的问题，我们一定要考虑是否有很多重复计算。显然对于 `f(n) = f(n-1) + f(n-2)` 的递归，是有很多重复计算的

这个时候我们要考虑状态保存。例如用 Map 来进行保存，当然用一个数组也是可以的，这个时候就像我们上面说的巧用数组下标了。可以当`arr[n] = 0`时，表示n还没计算过，当`arr[n] != 0`时，表示`f(n)`已经计算过，这时就可以把计算过的值直接返回回去了

这样，可以极大着提高算法的效率。也有人把这种状态保存称之为**备忘录法**

#### 考虑自底向上

对于递归的问题，我们一般都是从上往下递归的，直到递归到最底，再一层一层着把值返回

不过，有时候当n比较大的时候，例如当 n = 10000时，那么必须要往下递归10000层直到 n <=2 才将结果慢慢返回，如果n太大的话，可能栈空间会不够用

对于这种情况，其实我们是可以考虑自底向上的做法的。例如我知道 `f(1) = 1;`, `f(2) = 2;`. 那么我们就可以推出 `f(3) = f(2) + f(1) = 3`。从而可以推出`f(4)`, `f(5)`等直到`f(n)`。因此，我们可以考虑使用自底向上的方法来做, 我们也把这种自底向上的做法称之为**递推**


-----------------------------------------------------

## 常见算法技巧

### 1. 确定函数名字与原型

一旦拿到有关算法的问题，那么就应该分析问题，找到对应的输入输出，从而确定出算法的函数原型。我们写算法，其实就是写一个或者若干个普通的函数。因此，需要分析出，应该传什么参数给函数，函数处理完后，应该把什么数据作为结果返回。最后还要给函数取一个符合算法意义的名字，名字最好用英语表示，如果用拼音，会显得特别山寨的感觉。函数的命名方式与变量的命名方式都有相关的约定，比如匈牙利命名法，Linux命名法或者驼峰命名法等

此外，就是需要有模块化的思想。一个函数只单独完成一个单一的功能，函数的代码行数一般很少超过100行，加上注释不会超过300行。 因此，要把那些频繁使用而功能又比较单一的代码放在一个独立的函数里。不要在一个函数里完成N个功能，这不利于调试和维护，也和模块化是相背离的

### 2. 严进宽出

确定好了函数的原型之后，紧接着在完成这个函数的功能一开始的地方，就需要严格判断函数输入参数的合法性，我们称之为：严进宽出。具体点说，就是要判断:
- 函数参数中的指针是否为NULL
- 函数参数中缓存的长度是否在合理范围
- 对参数类型进行检查

严进宽出是写程序的一个非常好的习惯，可以避免程序在运行中出错，甚至避免各种严重漏洞的产生。比如曾经十分严重的SSL协议中的心脏流血漏洞，就是因为服务端程序在处理的时候，没有验证来自客户端对应的缓存长度的有效性，而造成了该漏洞的产生。同样，对于号称漏洞核弹的微软CVE-2017-0290漏洞，也是因为在扫描引擎MsMpEng的NScript模块中没有对输入的参数类型进行检查就默认当做字符串来处理造成的

此外，在函数内部定义的局部变量，都应该进行初始化，因为未初始化的变量，包含的都是一些没有意义的随机值，初始化可以防止在使用过程中使用了垃圾值的变量，影响程序的判断，尤其是指针，可以防止野指针破坏程序中的数据

### 3. 边界考虑

边界考虑就是要考虑程序中各种各样的特殊情况，而不是只考虑其中的一种情况。我们在写算法的时候，经常会忘记多种情况的周全考虑，而忽略了很多特殊的情况，对程序的健壮性带来影响

### 4. 出错处理

出错处理，是指当代码在执行过程中，如果发生了异常或者错误，就必须要处理，否则程序就无法继续执行了，如果强制继续执行，往往可能会导致程序或者系统崩溃

### 5. 性能优化（时间复杂度，空间复杂度）

总的来说，衡量算法的优劣有2种标准：时间复杂度和空间复杂度。简单的来说，所谓时间复杂度，就是嵌套的循环越少越好，比如一层循环优于二层循环，面试中一般很少有三层循环的算法；而所谓空间复杂度，就是尽量不要调用malloc或者new来分配额外的内存。复杂度可以用O（）来表示，它们之间的效率关系为：`O(1)>O(logn)>O(n)>O(nlogn)>O(n²)>O(2^n)`

### 6. 循环的掌握

一个再复杂的算法程序，都是由**循环，条件，顺序**三种语句构成的。而这三种语句中，**循环语句**的使用是其中的关键。循环语句用来遍历和操作对应的数据结构，在遍历的过程中，完成对数据的处理和问题的解决。以循环语句为核心，循环语句把其他语句联系起来。因此，算法中，最重要的地方就是对循环的熟练掌握与使用

熟练各种循环语句的写法，为实现各种复杂的算法奠定了基础。因此，要在各种循环语句上下功夫，达到熟练书写，灵活运用的程度

### 7. 递归的应用

对于一些复杂的算法问题，还可以通过递归的思想来解决。有的问题，用传统的方法来解决，显得很复杂。这个时候，可以考虑是不是可以用递归来解决。因为用递归的思想解决问题，既简单，又清晰，往往让看似复杂的问题得到简单解决的可能

对于**树的问题**，几乎都可以考虑用递归的方法去实现，按照递归的方法，首先分析了这个问题最简单的情况（即递归的终止条件），然后再对复杂的情况利用递归方法调用它自身

**递归算法的关键是找到递归的终止条件和递归公式**

### 8. 2个指针跑步

2个指针跑步法，是麦洛克菲在算法教学过程中总结的一个很好的编程方法。就是在算法实现过程中，我们可以定义2个（有时候甚至是3个或者多个）指针，一前一后同向或者相向而行，同时遍历对应的数据结构（如数组，链表，字符串等），在遍历过程中解决对应的问题。如果我们把循环比喻成算法问题中的导演，那么2个指针就是算法中的男女主角，对问题的解决起着重要的作用。在大量的名企面试题中，都可以使用该方法来解决并降低算法的复杂度

### 9. Hash算法

善用map 类型


--------------------------------------------------

### 算法思路指南

#### 数据结构的存储方式

数据结构的存储方式只有两种：
- 数组，链式存储
- 链表，链式存储

散列表、栈、队列、堆、树、图等等各种数据结构都属于「上层建筑」，数组和链表才是「结构基础」，这些多样化的数据结构，究其源头，都是在链表或者数组上的特殊操作

比如说「队列」、「栈」这两种数据结构既可以使用链表也可以使用数组实现。用数组实现，就要处理扩容缩容的问题；用链表实现，没有这个问题，但需要更多的内存空间存储节点指针

「图」的两种表示方法，邻接表就是链表，邻接矩阵就是二维数组。邻接矩阵判断连通性迅速，并可以进行矩阵运算解决一些问题，但是如果图比较稀疏的话很耗费空间。邻接表比较节省空间，但是很多操作的效率上肯定比不过邻接矩阵

「散列表」就是通过散列函数把键映射到一个大数组里。而且对于解决散列冲突的方法，拉链法需要链表特性，操作简单，但需要额外的空间存储指针；线性探查法就需要数组特性，以便连续寻址，不需要指针的存储空间，但操作稍微复杂些

「树」，用数组实现就是「堆」，因为「堆」是一个完全二叉树，用数组存储不需要节点指针，操作也比较简单；用链表实现就是很常见的那种「树」，因为不一定是完全二叉树，所以不适合用数组存储。为此，在这种链表「树」结构之上，又衍生出各种巧妙的设计，比如二叉搜索树、AVL 树、红黑树、区间树、B 树等等，以应对不同的问题


- 数组由于是紧凑连续存储,可以随机访问，通过索引快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)
- 链表因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 O(1)。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间

#### 数据结构的基本操作

**对于任何数据结构，其基本操作无非`遍历 + 访问`，再具体一点就是：`增删查改`**

数据结构种类很多，但它们存在的目的都是在不同的应用场景，尽可能高效地增删查改, 这就是数据结构的使命

各种数据结构的遍历 + 访问无非两种形式：
- 线性
- 非线性

**线性就是 `for/while` 迭代为代表，非线性就是递归为代表**


数组遍历框架，典型的线性迭代结构:
```
func traverse(arr []int) {
   for i := 0; i < len(arr); i++ {
      //迭代访问arr[i]
   }
}
```

链表遍历框架，兼具迭代和递归结构:
```
type ListNode struct {
   Val int
   Next *LIstNode
}

//迭代访问
func traverse(head *ListNode) {
   for head != nil {
      //迭代访问 head.Val
      head = head.Next
   }
}

//递归访问
func traverse(head *ListNode) {
   //递归访问 head.Val
   traverse(head.Next)
}
```

二叉树遍历框架，典型的非线性递归遍历结构:
```
type TreeNode struct {
   Val int
   Left *ListNode
   Right *ListNode
}

func traverse(root *TreeNode) {
   fmt.Println(root.Val)
   traverse(root.Left)
   traverse(root.Right)
}
```

**所谓框架，就是套路。不管增删查改，这些代码都是永远无法脱离的结构，你可以把这个结构作为大纲，根据具体问题在框架上添加代码就行了**

#### 算法刷题指南

首先要明确的是，数据结构是工具，算法是通过合适的工具解决特定问题的方法。也就是说，学习算法之前，最起码得了解那些常用的数据结构，了解它们的特性和缺陷

先刷二叉树题目，因为二叉树是最容易培养框架思维的，而且大部分算法技巧，本质上都是树的遍历问题，几乎所有二叉树的题目都是一套这个框架就出来了：
```
func traverse(root *ListNode) {
   //前序遍历
   traverse(root.Left)
   //中序遍历
   traverse(root.Right)
   //后序遍历
}
```

常见问题：
- 求二叉树中最大路径和
- 根据前序遍历和中序遍历的结果还原一棵二叉树


**在回溯，分治，动态规划问题中，涉及到递归问题的，大部分都是树的问题**

很多动态规划问题就是在遍历一棵树，如果对树的遍历操作烂熟于心，知道怎么把思路转化成代码，知道如何提取别人解法的核心思路，就ok了

*数据结构的基本存储方式就是链式和顺序两种，基本操作就是增删查改，遍历方式无非迭代和递归*


-------------------------------------------

### 递归理解

**尾递归**: 如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。 当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。 尾递归函数的特点是在回归过程中不用做任何操作，这个特性很重要，因为大多数现代的编译器会利用这种特点自动生成优化的代码

尾递归特征:
- 在尾部调用的是函数自身
- 可通过优化，使得计算仅占用常量栈空间

```
def recsum(x):
  if x == 1:
    return x
  else:
    return x + recsum(x - 1)
```

递归三要素：
- 确定递归函数功能
- 找出递归结束的条件
- 找出函数的等价关系式

递归函数往往可以简化我们的代码，尤其是对树的遍历和利用回溯算法写代码的时候，但是**递归函数的返回值**往往是困扰我们的。

总体来说，我们先要理解函数的调用过程，函数调用过程会用栈来保存函数的返回值和过程，而递归函数就是调用自身函数的过程，所以也是用栈存储，这样就比较容易理解了

递归函数是用栈存储函数返回值和中间过程，每次返回栈顶的结果（包括中间的输出值和返回值），而**递归函数最终的返回值的是栈底的值，也就是递归函数第一次调用时的返回值**


写递归算法的关键是要明确函数的「定义」是什么，然后相信这个定义，利用这个定义推导最终结果，绝不要跳入递归的细节

---------------------------------------------------------

### 动态规划

动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解

动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解

与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的填表格式

