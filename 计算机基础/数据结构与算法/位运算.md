## 位运算

常用的位运算操作:

- `&`, 与，两个位都为1时，结果才为1
- `|`, 或, 两个位都为0时，结果才为0
- `^`, 异或, 两个位相同为0，相异为1
- `~`, 取反, 0变1，1变0
- `<<`, 左移, 各二进位全部左移若干位，高位丢弃，低位补0
- `>>`, 右移, 各二进位全部右移若干位


### 按位与运算

```
0&0 = 0
0&1 = 0
1&0 = 0
1&1 = 1
```

**两位同时为1，结果才为1，否则结果为0**

#### 与运算的用途

待补充

### 按位或运算

```
0|0 = 0
0|1 = 1
1|0 = 1
1|1 = 1
```

**参加运算的两个对象只要有一个为1，其值为1**

#### 或运算的用途

待补充

### 异或运算

```
0^0 = 0
0^1 = 1
1^0 = 1
1^1 = 0
```

**参加运算的两个对象，如果两个相应位相同为0，相异为1**

#### 异或运算的用途

待补充


### 取反运算

```
~1 = 0
~0 = 1
```

**对一个二进制数按位取反，即将0变1，1变0**

#### 取反运算的用途

待补充


### 左移运算

```
a = a<<2
```

**将一个运算对象的各二进制位全部左移若干位,左边的二进制位丢弃，右边补0**

**若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2**


### 右移运算

```
a = a>>2
```

**将一个数的各二进制位全部右移若干位**

**操作数每右移一位，相当于该数除以2**


--------------------------------------


```
a &= b   ==> a = a&b
a |= b   ==> a = a|b
a >>= b  ==> a = a>>b
a <<= b  ==> a = a<<b
a ^= b   ==> a = a^b
```

-----------------------------------------------------

计算机中的数在内存中都是以二进制形式进行存储的，用位运算就是直接对整数在内存中的二进制位进行操作，因此其执行效率非常高，在程序中使用位运算进行操作，这会大大提高程序的性能


### 位运算实现乘法

数 a 向右移一位，相当于将 a 除以 2；数 a 向左移一位，相当于将 a 乘以 2

```
a := 2
a >> 1  // 结果为 1
a << 1  // 结果为 4
```

### 位操作交换两个数

位操作交换两数可以不需要第三个临时变量
```
//普通交换操作
func swap(a int, b int) {
    a = a + b
    b = a - b
    a = a - b
}

//位异或操作
func swap(a int, b int) {
    a ^= b
    b ^= a
    a ^= b
}

a ^= b ---> a = (a^b)
b ^= a ---> b = b^(a^b) ---> b = (b^b)^a = a
a ^= b ---> a = (a^b)^a = (a^a)^b = b
```

### 位操作判断奇偶

只要根据数的最后一位是 0 还是 1 来决定即可，为 0 就是偶数，为 1 就是奇数

```
if 0 == (a & 1) {
    //偶数
}
```

### 位操作交换正负号

交换符号将正数变成负数，负数变成正数

```
func reversal(a int) int {
    return ^a + 1
}
```

正数取反加1，正好变成其对应的负数(补码表示)；负数取反加一，则变为其原码，即正数

### 位操作求绝对值

正数的绝对值是其本身，负数的绝对值正好可以对其进行取反加一求得，即我们首先判断其符号位（正数右移 31 位得到 0，负数右移 31 位得到 -1,即 0xffffffff），然后根据符号进行相应的操作

```
func abs(a int) int {
    i := a >> 31
    if i == 0 {
        return a
    }
    return ^a + 1
}
```

### 位操作进行高低位交换

给定一个 16 位的无符号整数，将其高 8 位与低 8 位进行交换，求出交换后的值

```
34520的二进制表示：
10000110 11011000

将其高8位与低8位进行交换，得到一个新的二进制数：
11011000 10000110
其十进制为55430
```

从上面移位操作我们可以知道，只要将无符号数 `a>>8` 即可将其高 8 位移到低 8 位，高位补 0；将 `a<<8` 即可将低 8 位移到高 8 位，低 8 位补 0，然后将 `a>>8` 和 `a<<8` 进行或操作既可求得交换后的结果

```
 a := 34520
a = (a >> 8) | (a << 8)
```

### 位运算法则

位运算的优先级，记不住的话，多用括号

#### 位运算的信息丢失

位运算中**与**、**或** 会造成信息丢失，他们是单向运算，不可逆运算

```
1 & x = y
知道x 可以求出y
知道y 不可能求出x
当y = 0, x 可能等于0，2，6……
```

**左移**, **右移** 在数据溢出时也会信息丢失

**异或** 不会造成信息丢失，而且具有很好的性质

```
x ^ a = y
当a 确定时，x与y 一一对应，且
x = y ^ a
```

正因为异或不会造成信息丢失，异或可以进行运算的交换运算，否则在交换中信息丢失，会导致无法还原

```
// a 与 b 互换
a ^= b
b ^= a
a ^= b
```

由于位运算中可能的信息丢失，位运算的优先级特别重要，顺序不同，丢失的信息不同，结果就不同

```
(3 | 1) & 2  = 2
3 | 1 & 2 = 3
```

#### 运算性质

```
交换律:
a | b = b | a
a & b = b & a
a ^ b = b ^ a

结合律:
(3 | 1) & 2  = 2
3 | 1 & 2 = 3
证明结合律是失效的

分配律:
(3 | 1) & 2  = 2
3 | 1 & 2 = 3
证明结合律是失效的
```

因此，一般情况下，结合律和分配律是失效的，只有交换律能安全使用, 失效的原因与运算中的信息丢失有关

#### 比较两个值是否相等

```
a ^ b == 0
```

--------------------------------------------------------

### 异或运算

