## 二叉树解题

### 二叉树的种类

- 满二叉树
- 完全二叉树
- 二叉搜索树
- 平衡二叉搜索树

满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树

在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。**优先级队列其实是一个堆，堆就是一棵完全二叉树**

二叉搜索树是一个有序树，若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值，若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值，它的左、右子树也分别为二叉排序树

平衡二叉搜索树：又被称为AVL树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树


### 二叉树的存储方式

- 链式存储，链式存储方式就用指针
- 顺序存储，顺序存储的方式就是用数组

顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在散落在各个地址的节点串联一起

### 二叉树的遍历方式

- 深度优先遍历：先往深走，遇到叶子节点再往回走
- 广度优先遍历：一层一层的去遍历

#### 深度优先遍历
- 前序遍历（递归法，迭代法）
- 中序遍历（递归法，迭代法）
- 后序遍历（递归法，迭代法）

#### 广度优先遍历
- 层次遍历（迭代法）


栈就是递归的一种是实现结构，前中后序遍历的逻辑其实都是可以借助栈使用非递归的方式来实现的

广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树

### 二叉树的定义

```
type TreeNode struct {
    Val int
    Left *TreeNode
    Right *TreeNode
}
```

二叉树的定义 和链表是差不多的，相对于链表 ，二叉树的节点里多了一个指针， 有两个指针，指向左右孩子

------------------------------------------------------------

### 为递归而生---树

「确定递归函数的参数和返回值：」确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型

「确定终止条件：」写完了递归算法,  运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对

「确定单层递归的逻辑：」确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程

#### 以前序遍历举例

*确定递归函数的参数和返回值:*

因为要打印出前序遍历节点的数值，所以参数里需要传入节点的数值，除了这一点就不需要在处理什么数据了也不需要有返回值
```
func traversal(root *TreeNode) {

}
```

*确定终止条件:*

在递归的过程中，如何算是递归结束了呢，当然是当前遍历的节点是空了，那么本层递归就要要结束了，所以如果当前遍历的这个节点是空，就直接`return`
```
func traversal(root *TreeNode) {
    if root == nil {
        return
    }
}
```

*确定单层递归的逻辑:*

前序遍历是中左右的循序，所以在单层递归的逻辑，是要先取中节点的数值
```
func traversal(root *TreeNode) {
    if root == nil {
        return
    }

    fmt.Println(root.Val)
    traversal(root.Left)
    traversal(root.Right)
}
```

```
func preorderTraversal(root *TreeNode) (vals []int) {
    var preorder func(*TreeNode)
    preorder = func(node *TreeNode) {
        if node == nil {
            return
        }
        vals = append(vals, node.Val)
        preorder(node.Left)
        preorder(node.Right)
    }
    preorder(root)
    return
}
```

单层递归的逻辑就是按照中左右的顺序来处理的，这样二叉树的前序遍历，基本就写完了

----------------------------------------------------------

### 二叉树遍历---迭代法

一般递归可以做的，使用栈也可以做到

我们也可以用迭代的方式实现方法一的递归函数，两种方式是等价的，区别在于递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来，其余的实现与细节都相同

递归的实现就是，每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中」，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因


前序遍历是根左右，每次先处理的是根节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子，为什么要先加入 右孩子，再加入左孩子呢？因为这样出栈的时候才是根左右的顺序

```
func preorderTraversal(root *TreeNode) (vals []int) {
    stack := []*TreeNode{}
    node := root
    for node != nil || len(stack) > 0 {
        for node != nil {
            vals = append(vals, node.Val)
            stack = append(stack, node)
            node = node.Left
        }
        node = stack[len(stack)-1].Right
        stack = stack[:len(stack)-1]
    }
    return
}
```

