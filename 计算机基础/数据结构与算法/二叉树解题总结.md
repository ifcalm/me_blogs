## 二叉树解题

### 二叉树的种类

- 满二叉树
- 完全二叉树
- 二叉搜索树
- 平衡二叉搜索树

满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树

在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。**优先级队列其实是一个堆，堆就是一棵完全二叉树**

二叉搜索树是一个有序树，若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值，若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值，它的左、右子树也分别为二叉排序树

平衡二叉搜索树：又被称为AVL树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树


### 二叉树的存储方式

- 链式存储，链式存储方式就用指针
- 顺序存储，顺序存储的方式就是用数组

顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在散落在各个地址的节点串联一起

### 二叉树的遍历方式

- 深度优先遍历：先往深走，遇到叶子节点再往回走
- 广度优先遍历：一层一层的去遍历

#### 深度优先遍历
- 前序遍历（递归法，迭代法）
- 中序遍历（递归法，迭代法）
- 后序遍历（递归法，迭代法）

#### 广度优先遍历
- 层次遍历（迭代法）


栈就是递归的一种是实现结构，前中后序遍历的逻辑其实都是可以借助栈使用非递归的方式来实现的

广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树

### 二叉树的定义

```
type TreeNode struct {
    Val int
    Left *TreeNode
    Right *TreeNode
}
```

二叉树的定义 和链表是差不多的，相对于链表 ，二叉树的节点里多了一个指针， 有两个指针，指向左右孩子

------------------------------------------------------------

### 为递归而生---树

「确定递归函数的参数和返回值：」确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型

「确定终止条件：」写完了递归算法,  运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对

「确定单层递归的逻辑：」确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程

#### 以前序遍历举例

*确定递归函数的参数和返回值:*

因为要打印出前序遍历节点的数值，所以参数里需要传入节点的数值，除了这一点就不需要在处理什么数据了也不需要有返回值
```
func traversal(root *TreeNode) {

}
```

*确定终止条件:*

在递归的过程中，如何算是递归结束了呢，当然是当前遍历的节点是空了，那么本层递归就要要结束了，所以如果当前遍历的这个节点是空，就直接`return`
```
func traversal(root *TreeNode) {
    if root == nil {
        return
    }
}
```

*确定单层递归的逻辑:*

前序遍历是中左右的循序，所以在单层递归的逻辑，是要先取中节点的数值
```
func traversal(root *TreeNode) {
    if root == nil {
        return
    }

    fmt.Println(root.Val)
    traversal(root.Left)
    traversal(root.Right)
}
```

```
func preorderTraversal(root *TreeNode) (vals []int) {
    var preorder func(*TreeNode)
    preorder = func(node *TreeNode) {
        if node == nil {
            return
        }
        vals = append(vals, node.Val)
        preorder(node.Left)
        preorder(node.Right)
    }
    preorder(root)
    return
}
```

单层递归的逻辑就是按照中左右的顺序来处理的，这样二叉树的前序遍历，基本就写完了

----------------------------------------------------------

### 二叉树遍历---迭代法

一般递归可以做的，使用栈也可以做到

我们也可以用迭代的方式实现方法一的递归函数，两种方式是等价的，区别在于递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来，其余的实现与细节都相同

递归的实现就是，每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中」，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因


前序遍历是根左右，每次先处理的是根节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子，为什么要先加入 右孩子，再加入左孩子呢？因为这样出栈的时候才是根左右的顺序

```
func preorderTraversal(root *TreeNode) (vals []int) {
    stack := []*TreeNode{}
    node := root
    for node != nil || len(stack) > 0 {
        for node != nil {
            vals = append(vals, node.Val)
            stack = append(stack, node)
            node = node.Left
        }
        node = stack[len(stack)-1].Right
        stack = stack[:len(stack)-1]
    }
    return
}
```

-----------------------------------------------

### 二叉树的层序遍历

层序遍历一个二叉树, 就是从左到右一层一层的去遍历二叉树

**队列先进先出，符合一层一层遍历的逻辑，而是用栈先进后出适合模拟深度优先遍历也就是递归的逻辑**

```
func levelOrder(root *TreeNode) [][]int {
    ret := [][]int{}
    if root == nil {
        return ret
    }
    q := []*TreeNode{root}
    for i := 0; len(q) > 0; i++ {
        ret = append(ret, []int{})
        p := []*TreeNode{}
        for j := 0; j < len(q); j++ {
            node := q[j]
            ret[i] = append(ret[i], node.Val)
            if node.Left != nil {
                p = append(p, node.Left)
            }
            if node.Right != nil {
                p = append(p, node.Right)
            }
        }
        q = p
    }
    return ret
}
```

-------------------------------------------------------------

二叉树算法设计的总路线: 把当前节点要做的事做好，其他的交给递归框架，不用当前节点操心

如果当前节点会对下面的子节点有整体影响，可以通过辅助函数增长参数列表，借助参数传递信息

删除二叉搜索树的节点有三种情况:
- A 恰好是末端节点，两个子节点都为空，那么它可以当场去世了
- A 只有一个非空子节点，那么它要让这个孩子接替自己的位置
- A 有两个子节点，麻烦了，为了不破坏 BST 的性质，A 必须找到左子树中最大的那个节点，或者右子树中最小的那个节点来接替自己


----------------------------------------------------------

### 树的解题技巧

#### 一个中心

一个中心指的是**树的遍历**。整个树的专题只有一个中心点，那就是树的遍历，大家务必牢牢记住

树的遍历的本质就是把树的每个元素都访问一遍，任何数据结构的遍历不都是如此么？。但怎么访问的？不能直接访问叶子节点啊，必须得从根节点开始访问，然后根据子节点指针访问子节点，但是子节点有多个方向，所以又有了先访问哪个的问题，这造成了不同的遍历方式

而遍历不是目的，遍历是为了更好地做处理，这里的处理包括搜索，修改树等。树虽然只能从根开始访问，但是我们可以选择在访问完毕回来的时候做处理，还是在访问回来之前做处理，这两种不同的方式就是后序遍历和先序遍历

而树的遍历又可以分为两个基本类型，分别是**深度优先遍历和广度优先遍历**

#### 两个基本点

树的遍历有两种基本方式:
- 深度优先遍历
- 广度优先遍历

DFS 适合做一些暴力枚举的题目，DFS 如果借助函数调用栈，则可以轻松地使用递归来实现

BFS 不是 层次遍历, FS 适合求最短距离，这个和层次遍历是不一样的，很多人搞混。这里强调一下，层次遍历和 BFS 是完全不一样的东西, 层次遍历就是一层层遍历树，按照树的层次顺序进行访问

BFS 的核心在于求最短问题时候可以提前终止，这才是它的核心价值，层次遍历是一种不需要提前终止的 BFS 的副产物. 这个提前终止不同于 DFS 的剪枝的提前终止，而是找到最近目标的提前终止。比如我要找距离最近的目标节点，BFS 找到目标节点就可以直接返回。而 DFS 要穷举所有可能才能找到最近的，这才是 BFS 的核心价值。实际上，我们也可以使用 DFS 实现层次遍历的效果，借助于递归，代码甚至会更简单

##### 深度优先遍历

深度优先搜索算法是一种用于遍历树或图的算法。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点 v 的所在边都己被探寻过，搜索将回溯到发现节点 v 的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止，属于盲目搜索

深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的相应拓扑排序表，利用拓扑排序表可以方便的解决很多相关的图论问题，如最大路径问题等等

**对于树的题目，我们基本上都可以使用 DFS 来解决，甚至我们可以基于 DFS 来做层次遍历，而且由于 DFS 可以基于递归去做，因此算法会更简洁。在对性能有很高要求的场合，我建议你使用迭代，否则尽量使用递归，不仅写起来简单快速，还不容易出错**

