### golang 计算 【四舍五入】

go官方的math 包中提供了取整的方法，向上取整`math.Ceil()`，向下取整`math.Floor()`

golang没有类似python的`round()`函数，搜了一下很多都非常复杂，最后看到了一个清新脱俗的：先`+0.5`，然后向下取整！

```
package main
 
import (
    "fmt"
    "math"
)
 
func main() {
    var s float64
    for {
        _, err := fmt.Scanln(&s)
        if err != nil {
            break
        }
        fmt.Println(int(math.Floor(s+0.5)))
    }
}
```

---------------------------------------

### 计算一个整数在二进制形式下包含多少 1

```
package main
 
import "fmt"
 
func main() {
    var n,num int
    for {
        _, err := fmt.Scanln(&n)
        if err != nil {
            break
        }
         
        //n&(n-1) 可以消除n的最后一个1
        for n != 0 {
            n = n&(n-1)
            num++
        }
        fmt.Println(num)
    }
}
```

考察位运算

-------------------------------------------------

### 输入一个整数，将这个整数以字符串的形式逆序输出

```
package main
 
import (
    "fmt"
    "strconv"
)
 
func main() {
    var n int
    for {
        //检测控制台输入
        _, err := fmt.Scanln(&n)
        if err != nil {
            break
        }
        //把int转换为string,不使用 string()函数，它会转换为整数对应的ASCII码
        s := []byte(strconv.Itoa(n))
        //使用对撞指针交换位置
        start, end := 0, len(s)-1
        for start < end {
            s[start], s[end] = s[end], s[start]
            start++
            end--
        }
        fmt.Println(string(s))
    }
}
```

考察点：双指针

- 在golang中int 转 string 使用 `strconv.Itoa()`函数，`string()`函数会把整数转换为对于的ASCII码
- 注意两个指针的边界位置
- []byte 与 string 之间的相互转换
- 注意两个指针的边界位置


----------------------------------------------------

### 统计大写字母个数

```
package main
 
import (
    "fmt"
    "io"
    "strings"
    "bufio"
    "os"
)
 
func main() {
 
    str := "QWERTYUIOPLKJHGFDSAZXCVBNM"
    inputReader := bufio.NewReader(os.Stdin)
    for {
        input, err := inputReader.ReadString('\n')
        if err == io.EOF {
            break
        } else if err != nil {
            break
        }
        n := 0
        for _, v := range []byte(input) {
            if strings.Contains(str, string(v)) {
                n++
            }
        }
        fmt.Println(n)
    }
}
```

- 字符串包含字串函数 strings.Contains(str, sonstr)
- 字符串与字节之间的转换

-----------------------------------------

### 计算字符串中含有的不同字符的个数

```
package main
 
import (
    "fmt"
    "bufio"
    "os"
    "io"
    "strings"
)
 
func main() {
    inputReader := bufio.NewReader(os.Stdin)
    for {
        input, err := inputReader.ReadString('\n')
        if err == io.EOF {
            break
        } else if err != nil {
            break
        }
        //替换掉换行符
        input = strings.Replace(input, "\n", "", -1)
 
        //map 存储不同字符
        m := make(map[string]struct{})
        for _, v := range input {
            if _, ok := m[string(v)]; !ok {
                m[string(v)] = struct{}{}
            }
        }
        //获取map长度
        fmt.Println(len(m))
    }
}
```

- map掌握要好
- map长度计算，可使用len() 计算
- 使用map 键的唯一性

----------------------------------------------

### 输入一个int型整数，按照从右向左的阅读顺序，返回一个不含重复数字的新的整数

```
package main
 
import (
    "bufio"
    "os"
    "io"
    "fmt"
    "strings"
    "strconv"
)
 
func main() {
    inputReader := bufio.NewReader(os.Stdin)
    for {
        input, err := inputReader.ReadString('\n')
        if err == io.EOF {
            break
        } else if err != nil {
            break
        }
        input = strings.Replace(input, "\n", "", -1)
         
        //逆序输入的字符串
        inputB := []byte(input)
        start, end := 0, len(input)-1
        for start < end {
            inputB[start], inputB[end] = inputB[end], inputB[start]
            start++
            end--
        }
        input = string(inputB)
 
        stack := make([]string, 0)
        m := make(map[string]struct{})
 
        //去除重复的字节
        for _, v := range input {
            if _, ok := m[string(v)]; !ok {
                stack = append(stack, string(v))
                m[string(v)] = struct{}{}
            }
        }
         
        //把字符串数组拼接成字符串
        result, err := strconv.Atoi(strings.Join(stack, ""))
        if err != nil {
            fmt.Println(err)
        }
        fmt.Println(result)
    }
}
```

- 先逆序在去重
- 使用map去重
- 字符串拼接函数 strings.Join(), 把字符串切片拼接为字符串
- 使用双指针进行字符串逆序

--------------------------------------

### 句子逆序

```
package main
 
import (
    "bufio"
    "os"
    "io"
    "strings"
    "fmt"
)
 
func main() {
    inputReader := bufio.NewReader(os.Stdin)
    for {
        input, err := inputReader.ReadString('\n')
        if err == io.EOF {
            break
        } else if err != nil {
            fmt.Println(err)
            break
        }
        input = strings.Replace(input, "\n", "", -1)
 
        //字符串分割
        result := strings.Fields(input)
 
        //使用双指针进行逆序
        start, end := 0, len(result)-1
        for start < end {
            result[start], result[end] = result[end], result[start]
            start++
            end--
        }
 
        //把字符串切片拼接为字符串
        fmt.Println(strings.Join(result, " "))
    }
}
```

- 使用空格进行分割
- 使用双指针进行逆序
- 字符串分割函数 strings.Fields()，strings.Split()
- 字符串拼接函数 strings.Join()

------------------------------------------------

### 截取字符串

```
package main
 
import (
    "bufio"
    "os"
    "io"
    "fmt"
    "strings"
    "strconv"
)
 
func main() {
    inputReader := bufio.NewReader(os.Stdin)
    for {
        //获取2行数据后在做处理
        input1, err := inputReader.ReadString('\n')
        input2, err := inputReader.ReadString('\n')
        if err == io.EOF {
            break
        } else if err != nil {
            fmt.Println(err)
            break
        }
 
        input1 = strings.Replace(input1, "\n", "", -1)
        input2 = strings.Replace(input2, "\n", "", -1)
 
        index, err := strconv.Atoi(input2)
        if err != nil {
            fmt.Println(err)
        }
        fmt.Println(input1[:index])
    }
}
```

- 多行参数处理
- 注意换行符的处理，例如 \n , \r\n  等对字符串的影响


-------------------------------------------------

### 在字符串中找出连续最长的数字串

```
package main
 
import (
    "bufio"
    "os"
    "io"
    "strings"
    "fmt"
    "math"
)
 
func main() {
    inputReader := bufio.NewReader(os.Stdin)
    for {
        input, err := inputReader.ReadString('\n')
        if err == io.EOF {
            break
        } else if err != nil {
            fmt.Println(err)
            break
        }
        input = strings.Replace(input, "\n", "", -1)
 
        //把非数字字符替换为空
        b := []byte(input)
        for i, v := range b {
            if !strings.Contains("0123456789", string(v)) {
                b[i] = ' '
            }
        }
 
        //以空格来分割字符串，得到的就是数字字符串
        result := strings.Fields(string(b))
 
        //确定最长数字字符串的长度
        max := math.MinInt32
        for _, v := range result {
            if max < len(v) {
                max = len(v)
            }
        }
 
        //按照顺序拼接最长的数字字符串
        s := ""
        for _, v := range result {
            if len(v) == max {
                s += v
            }
        }
 
        //输出，注意换行
        fmt.Printf("%s,%d\n", s, max)
    }
}
```

- 在处理字符串问题时，可以把不需要的字符替换为空格，然后以空格进行分割
- 在字符串拼接是要注意拼接顺序，使用map保存字符串时，拼接的时候是无序拼接的
- map，数组，循环，指定输出类型，是否换行，byte和string之间的转换
- 字符串分割，字符串替换，子串包含
- 找最大值，找最小值


------------------------------------------------

### 判断链表中是否有环

```
func hasCycle(head *ListNode) bool {
     
    //快慢指针
    slow := head
    fast := head
 
    for fast != nil && fast.Next != nil {
        //慢指针每次走一步
        slow = slow.Next
        //快指针每次走两步
        fast = fast.Next.Next
        //如果相遇，说明有环
        if slow == fast {
            return true
        }
    }
    //否则就没有环
    return false
}
```

- 快慢指针，快指针走两步，慢指针走一步，若有环，快慢指针会相遇
- 注意保存头节点
- 链表尾节点的判断
- 链表的节点指向要注意，避免指针丢失

-------------------------------------------------

