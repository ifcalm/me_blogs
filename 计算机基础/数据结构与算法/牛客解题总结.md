### golang 计算 【四舍五入】

go官方的math 包中提供了取整的方法，向上取整`math.Ceil()`，向下取整`math.Floor()`

golang没有类似python的`round()`函数，搜了一下很多都非常复杂，最后看到了一个清新脱俗的：先`+0.5`，然后向下取整！

```
package main
 
import (
    "fmt"
    "math"
)
 
func main() {
    var s float64
    for {
        _, err := fmt.Scanln(&s)
        if err != nil {
            break
        }
        fmt.Println(int(math.Floor(s+0.5)))
    }
}
```

---------------------------------------

### 计算一个整数在二进制形式下包含多少 1

```
package main
 
import "fmt"
 
func main() {
    var n,num int
    for {
        _, err := fmt.Scanln(&n)
        if err != nil {
            break
        }
         
        //n&(n-1) 可以消除n的最后一个1
        for n != 0 {
            n = n&(n-1)
            num++
        }
        fmt.Println(num)
    }
}
```

考察位运算

-------------------------------------------------

### 输入一个整数，将这个整数以字符串的形式逆序输出

```
package main
 
import (
    "fmt"
    "strconv"
)
 
func main() {
    var n int
    for {
        //检测控制台输入
        _, err := fmt.Scanln(&n)
        if err != nil {
            break
        }
        //把int转换为string,不使用 string()函数，它会转换为整数对应的ASCII码
        s := []byte(strconv.Itoa(n))
        //使用对撞指针交换位置
        start, end := 0, len(s)-1
        for start < end {
            s[start], s[end] = s[end], s[start]
            start++
            end--
        }
        fmt.Println(string(s))
    }
}
```

考察点：双指针

- 在golang中int 转 string 使用 `strconv.Itoa()`函数，`string()`函数会把整数转换为对于的ASCII码
- 注意两个指针的边界位置
- []byte 与 string 之间的相互转换
- 注意两个指针的边界位置


----------------------------------------------------

### 统计大写字母个数

```
package main
 
import (
    "fmt"
    "io"
    "strings"
    "bufio"
    "os"
)
 
func main() {
 
    str := "QWERTYUIOPLKJHGFDSAZXCVBNM"
    inputReader := bufio.NewReader(os.Stdin)
    for {
        input, err := inputReader.ReadString('\n')
        if err == io.EOF {
            break
        } else if err != nil {
            break
        }
        n := 0
        for _, v := range []byte(input) {
            if strings.Contains(str, string(v)) {
                n++
            }
        }
        fmt.Println(n)
    }
}
```

- 字符串包含字串函数 strings.Contains(str, sonstr)
- 字符串与字节之间的转换

-----------------------------------------

### 计算字符串中含有的不同字符的个数

```
package main
 
import (
    "fmt"
    "bufio"
    "os"
    "io"
    "strings"
)
 
func main() {
    inputReader := bufio.NewReader(os.Stdin)
    for {
        input, err := inputReader.ReadString('\n')
        if err == io.EOF {
            break
        } else if err != nil {
            break
        }
        //替换掉换行符
        input = strings.Replace(input, "\n", "", -1)
 
        //map 存储不同字符
        m := make(map[string]struct{})
        for _, v := range input {
            if _, ok := m[string(v)]; !ok {
                m[string(v)] = struct{}{}
            }
        }
        //获取map长度
        fmt.Println(len(m))
    }
}
```

- map掌握要好
- map长度计算，可使用len() 计算
- 使用map 键的唯一性

----------------------------------------------

### 输入一个int型整数，按照从右向左的阅读顺序，返回一个不含重复数字的新的整数

```
package main
 
import (
    "bufio"
    "os"
    "io"
    "fmt"
    "strings"
    "strconv"
)
 
func main() {
    inputReader := bufio.NewReader(os.Stdin)
    for {
        input, err := inputReader.ReadString('\n')
        if err == io.EOF {
            break
        } else if err != nil {
            break
        }
        input = strings.Replace(input, "\n", "", -1)
         
        //逆序输入的字符串
        inputB := []byte(input)
        start, end := 0, len(input)-1
        for start < end {
            inputB[start], inputB[end] = inputB[end], inputB[start]
            start++
            end--
        }
        input = string(inputB)
 
        stack := make([]string, 0)
        m := make(map[string]struct{})
 
        //去除重复的字节
        for _, v := range input {
            if _, ok := m[string(v)]; !ok {
                stack = append(stack, string(v))
                m[string(v)] = struct{}{}
            }
        }
         
        //把字符串数组拼接成字符串
        result, err := strconv.Atoi(strings.Join(stack, ""))
        if err != nil {
            fmt.Println(err)
        }
        fmt.Println(result)
    }
}
```

- 先逆序在去重
- 使用map去重
- 字符串拼接函数 strings.Join(), 把字符串切片拼接为字符串
- 使用双指针进行字符串逆序

--------------------------------------

### 句子逆序

```
package main
 
import (
    "bufio"
    "os"
    "io"
    "strings"
    "fmt"
)
 
func main() {
    inputReader := bufio.NewReader(os.Stdin)
    for {
        input, err := inputReader.ReadString('\n')
        if err == io.EOF {
            break
        } else if err != nil {
            fmt.Println(err)
            break
        }
        input = strings.Replace(input, "\n", "", -1)
 
        //字符串分割
        result := strings.Fields(input)
 
        //使用双指针进行逆序
        start, end := 0, len(result)-1
        for start < end {
            result[start], result[end] = result[end], result[start]
            start++
            end--
        }
 
        //把字符串切片拼接为字符串
        fmt.Println(strings.Join(result, " "))
    }
}
```

- 使用空格进行分割
- 使用双指针进行逆序
- 字符串分割函数 strings.Fields()，strings.Split()
- 字符串拼接函数 strings.Join()

------------------------------------------------

### 截取字符串

```
package main
 
import (
    "bufio"
    "os"
    "io"
    "fmt"
    "strings"
    "strconv"
)
 
func main() {
    inputReader := bufio.NewReader(os.Stdin)
    for {
        //获取2行数据后在做处理
        input1, err := inputReader.ReadString('\n')
        input2, err := inputReader.ReadString('\n')
        if err == io.EOF {
            break
        } else if err != nil {
            fmt.Println(err)
            break
        }
 
        input1 = strings.Replace(input1, "\n", "", -1)
        input2 = strings.Replace(input2, "\n", "", -1)
 
        index, err := strconv.Atoi(input2)
        if err != nil {
            fmt.Println(err)
        }
        fmt.Println(input1[:index])
    }
}
```

- 多行参数处理
- 注意换行符的处理，例如 \n , \r\n  等对字符串的影响


-------------------------------------------------

