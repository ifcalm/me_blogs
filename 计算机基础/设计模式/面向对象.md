## 面向对象

#### 什么是面向对象编程和面向对象编程语言？

- 面向对象编程, OOP , Object Oriented Programming
- 面向对象编程语言, OOPL, Object Oriented Programming Language
- 面向对象分析, OOA, Object Oriented Analysis
- 面向对象设计, OOD, Object Oriented Design


#### 面向对象编程两个非常基础的概念

- 类, class
- 对象, object


#### 面向对象编程的四大特性

- 封装
- 抽象
- 继承
- 多态


### UML, 统一建模语言


-------------------------------------

**面向对象编程是一种编程范式或编程风格，它以类和对象作为组织代码的基本单元，并将封装，抽象，继承，多态 四个特性，作为代码设计和实现的基础**


### 封装

**封装也叫做信息隐藏或者数据访问保护**

封装的主要的目的是 隐藏信息和保护数据

类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息和数据

```
public class Wallet {
  private String id;
  private long createTime;
  private BigDecimal balance;
  private long balanceLastModifiedTime;

  public Wallet() {
     this.id = IdGenerator.getInstance().generate();
     this.createTime = System.currentTimeMillis();
     this.balance = BigDecimal.ZERO;
     this.balanceLastModifiedTime = System.currentTimeMillis();
  }

  
  public String getId() { return this.id; }
  public long getCreateTime() { return this.createTime; }
  public BigDecimal getBalance() { return this.balance; }
  public long getBalanceLastModifiedTime() { return this.balanceLastModifiedTime;  }

  public void increaseBalance(BigDecimal increasedAmount) {
    if (increasedAmount.compareTo(BigDecimal.ZERO) < 0) {
      throw new InvalidAmountException("...");
    }
    this.balance.add(increasedAmount);
    this.balanceLastModifiedTime = System.currentTimeMillis();
  }

  public void decreaseBalance(BigDecimal decreasedAmount) {
    if (decreasedAmount.compareTo(BigDecimal.ZERO) < 0) {
      throw new InvalidAmountException("...");
    }
    if (decreasedAmount.compareTo(this.balance) > 0) {
      throw new InsufficientAmountException("...");
    }
    this.balance.subtract(decreasedAmount);
    this.balanceLastModifiedTime = System.currentTimeMillis();
  }
}
```

Wallet 类有四个属性，我们根据封装特性，对这四个属性的访问进行了限制，调用者只被允许通过下面几个方法来访问或者修改数据

```
String getId()
long getCreateTime()
BigDecimal getBalance()
long getBalanceLastModifiedTime()
void increaseBalance(BigDecimal increasedAmount)
void decreaseBalance(BigDecimal decreasedAmount)

```

有些属性是不应该被修改的，有些属性是只能增加或者减少的，所以我们需要进行封装，不对外暴露不被允许的操作

封装需要借助**访问权限控制**

- private, 该关键字修饰的属性只能类本身访问
- public, 外部代码可以直接访问

**如果我们对类中属性的访问不做限制，那任何代码都可以访问、修改类中的属性，虽然这样看起来更加灵活，但从另一方面来说，过度灵活也意味着不可控，属性可以随意被以各种奇葩的方式修改，而且修改逻辑可能散落在代码中的各个角落，势必影响代码的可读性、可维护性**

类仅仅通过有限的方法暴露必要的操作，也能提高类的易用性。如果我们把类属性都暴露给类的调用者，调用者想要正确地操作这些属性，就势必要对业务细节有足够的了解。而这对于调用者来说也是一种负担。相反，如果我们将属性封装起来，暴露少许的几个必要的方法给调用者使用，调用者就不需要了解太多背后的业务细节，用错的概率就减少很多

### 抽象

抽象: 如何隐藏方法的具体实现，让调用者只需关心方法提供了哪些功能，并不需要知道这些功能是如何实现的

在面向对象中，一般借助于编程语言提供的接口类或者抽象类来实现抽象【java 中的 interface 和 abstract 关键字】

```
public interface IPictureStorage {
  void savePicture(Picture picture);
  Image getPicture(String pictureId);
  void deletePicture(String pictureId);
  void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo);
}

public class PictureStorage implements IPictureStorage {

  @Override
  public void savePicture(Picture picture) { ... }
  @Override
  public Image getPicture(String pictureId) { ... }
  @Override
  public void deletePicture(String pictureId) { ... }
  @Override
  public void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo) { ... }
}
```

我们利用 java 中的 interface 接口语法来实现抽象特性, 调用者在使用图片存储功能的时候，只需要了解 IPictureStorage 这个接口类暴露了哪些方法就可以了，不需要去查看 PictureStorage 类里的具体实现逻辑

实际上，抽象这个特性是非常容易实现的，并不需要非得依靠接口类或者抽象类这些特殊语法机制来支持。换句话说，并不是说一定要为实现类（PictureStorage）抽象出接口类（IPictureStorage），才叫作抽象。即便不编写 IPictureStorage 接口类，单纯的 PictureStorage 类本身就满足抽象特性

那是因为，类的方法是通过编程语言中的`函数`这一语法机制来实现的。通过函数包裹具体的实现逻辑，这本身就是一种抽象。调用者在使用函数的时候，并不需要去研究函数内部的实现逻辑，只需要通过函数的命名、注释或者文档，了解其提供了什么功能，就可以直接使用了。比如，我们在使用 C 语言的 `malloc()` 函数的时候，并不需要了解它的底层代码是怎么实现的**

**函数本身就是一种抽象**


抽象这个概念是一个非常通用的设计思想，并不单单用在面向对象编程中，也可以用来指导架构设计等。而且这个特性也并不需要编程语言提供特殊的语法机制来支持，只需要提供**函数**这一非常基础的语法机制，就可以实现抽象特性，有时并不被看作面向对象编程的特性之一


### 继承

继承是用来表示类之间的 `is-a` 关系【猫是一种哺乳动物】

继承可以分为 **单继承和多继承**，单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类【猫既是哺乳动物，又是爬行动物】


继承最大的好处就是 **代码复用**, 【假如两个类有一些相同的属性和方法，我们就可以将这些相同的部分，抽取到父类中，让两个子类继承父类。这样，两个子类就可以重用父类中的代码，避免代码重复写多遍】


### 多态


