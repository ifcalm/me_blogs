## 面向对象

#### 什么是面向对象编程和面向对象编程语言？

- 面向对象编程, OOP , Object Oriented Programming
- 面向对象编程语言, OOPL, Object Oriented Programming Language
- 面向对象分析, OOA, Object Oriented Analysis
- 面向对象设计, OOD, Object Oriented Design


#### 面向对象编程两个非常基础的概念

- 类, class
- 对象, object


#### 面向对象编程的四大特性

- 封装
- 抽象
- 继承
- 多态


### UML, 统一建模语言


-------------------------------------

**面向对象编程是一种编程范式或编程风格，它以类和对象作为组织代码的基本单元，并将封装，抽象，继承，多态 四个特性，作为代码设计和实现的基础**


### 封装

**封装也叫做信息隐藏或者数据访问保护**

类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息和数据

```
public class Wallet {
  private String id;
  private long createTime;
  private BigDecimal balance;
  private long balanceLastModifiedTime;

  public Wallet() {
     this.id = IdGenerator.getInstance().generate();
     this.createTime = System.currentTimeMillis();
     this.balance = BigDecimal.ZERO;
     this.balanceLastModifiedTime = System.currentTimeMillis();
  }

  
  public String getId() { return this.id; }
  public long getCreateTime() { return this.createTime; }
  public BigDecimal getBalance() { return this.balance; }
  public long getBalanceLastModifiedTime() { return this.balanceLastModifiedTime;  }

  public void increaseBalance(BigDecimal increasedAmount) {
    if (increasedAmount.compareTo(BigDecimal.ZERO) < 0) {
      throw new InvalidAmountException("...");
    }
    this.balance.add(increasedAmount);
    this.balanceLastModifiedTime = System.currentTimeMillis();
  }

  public void decreaseBalance(BigDecimal decreasedAmount) {
    if (decreasedAmount.compareTo(BigDecimal.ZERO) < 0) {
      throw new InvalidAmountException("...");
    }
    if (decreasedAmount.compareTo(this.balance) > 0) {
      throw new InsufficientAmountException("...");
    }
    this.balance.subtract(decreasedAmount);
    this.balanceLastModifiedTime = System.currentTimeMillis();
  }
}
```

Wallet 类有四个属性，我们根据封装特性，对这四个属性的访问进行了限制，调用者只被允许通过下面几个方法来访问或者修改数据

```
String getId()
long getCreateTime()
BigDecimal getBalance()
long getBalanceLastModifiedTime()
void increaseBalance(BigDecimal increasedAmount)
void decreaseBalance(BigDecimal decreasedAmount)

```

有些属性是不应该被修改的，有些属性是只能增加或者减少的，所以我们需要进行封装，不对外暴露不被允许的操作

封装需要借助**访问权限控制**

- private, 该关键字修饰的属性只能类本身访问
- public, 外部代码可以直接访问

**如果我们对类中属性的访问不做限制，那任何代码都可以访问、修改类中的属性，虽然这样看起来更加灵活，但从另一方面来说，过度灵活也意味着不可控，属性可以随意被以各种奇葩的方式修改，而且修改逻辑可能散落在代码中的各个角落，势必影响代码的可读性、可维护性**

类仅仅通过有限的方法暴露必要的操作，也能提高类的易用性。如果我们把类属性都暴露给类的调用者，调用者想要正确地操作这些属性，就势必要对业务细节有足够的了解。而这对于调用者来说也是一种负担。相反，如果我们将属性封装起来，暴露少许的几个必要的方法给调用者使用，调用者就不需要了解太多背后的业务细节，用错的概率就减少很多

### 抽象

