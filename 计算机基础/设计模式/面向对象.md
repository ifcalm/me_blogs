## 面向对象

#### 什么是面向对象编程和面向对象编程语言？

- 面向对象编程, OOP , Object Oriented Programming
- 面向对象编程语言, OOPL, Object Oriented Programming Language
- 面向对象分析, OOA, Object Oriented Analysis
- 面向对象设计, OOD, Object Oriented Design


#### 面向对象编程两个非常基础的概念

- 类, class
- 对象, object


#### 面向对象编程的四大特性

- 封装
- 抽象
- 继承
- 多态


### UML, 统一建模语言


-------------------------------------

**面向对象编程是一种编程范式或编程风格，它以类和对象作为组织代码的基本单元，并将封装，抽象，继承，多态 四个特性，作为代码设计和实现的基础**


### 封装

**封装也叫做信息隐藏或者数据访问保护**

封装的主要的目的是 隐藏信息和保护数据

类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息和数据

```
public class Wallet {
  private String id;
  private long createTime;
  private BigDecimal balance;
  private long balanceLastModifiedTime;

  public Wallet() {
     this.id = IdGenerator.getInstance().generate();
     this.createTime = System.currentTimeMillis();
     this.balance = BigDecimal.ZERO;
     this.balanceLastModifiedTime = System.currentTimeMillis();
  }

  
  public String getId() { return this.id; }
  public long getCreateTime() { return this.createTime; }
  public BigDecimal getBalance() { return this.balance; }
  public long getBalanceLastModifiedTime() { return this.balanceLastModifiedTime;  }

  public void increaseBalance(BigDecimal increasedAmount) {
    if (increasedAmount.compareTo(BigDecimal.ZERO) < 0) {
      throw new InvalidAmountException("...");
    }
    this.balance.add(increasedAmount);
    this.balanceLastModifiedTime = System.currentTimeMillis();
  }

  public void decreaseBalance(BigDecimal decreasedAmount) {
    if (decreasedAmount.compareTo(BigDecimal.ZERO) < 0) {
      throw new InvalidAmountException("...");
    }
    if (decreasedAmount.compareTo(this.balance) > 0) {
      throw new InsufficientAmountException("...");
    }
    this.balance.subtract(decreasedAmount);
    this.balanceLastModifiedTime = System.currentTimeMillis();
  }
}
```

Wallet 类有四个属性，我们根据封装特性，对这四个属性的访问进行了限制，调用者只被允许通过下面几个方法来访问或者修改数据

```
String getId()
long getCreateTime()
BigDecimal getBalance()
long getBalanceLastModifiedTime()
void increaseBalance(BigDecimal increasedAmount)
void decreaseBalance(BigDecimal decreasedAmount)

```

有些属性是不应该被修改的，有些属性是只能增加或者减少的，所以我们需要进行封装，不对外暴露不被允许的操作

封装需要借助**访问权限控制**

- private, 该关键字修饰的属性只能类本身访问
- public, 外部代码可以直接访问

**如果我们对类中属性的访问不做限制，那任何代码都可以访问、修改类中的属性，虽然这样看起来更加灵活，但从另一方面来说，过度灵活也意味着不可控，属性可以随意被以各种奇葩的方式修改，而且修改逻辑可能散落在代码中的各个角落，势必影响代码的可读性、可维护性**

类仅仅通过有限的方法暴露必要的操作，也能提高类的易用性。如果我们把类属性都暴露给类的调用者，调用者想要正确地操作这些属性，就势必要对业务细节有足够的了解。而这对于调用者来说也是一种负担。相反，如果我们将属性封装起来，暴露少许的几个必要的方法给调用者使用，调用者就不需要了解太多背后的业务细节，用错的概率就减少很多

### 抽象

抽象: 如何隐藏方法的具体实现，让调用者只需关心方法提供了哪些功能，并不需要知道这些功能是如何实现的

在面向对象中，一般借助于编程语言提供的接口类或者抽象类来实现抽象【java 中的 interface 和 abstract 关键字】

```
public interface IPictureStorage {
  void savePicture(Picture picture);
  Image getPicture(String pictureId);
  void deletePicture(String pictureId);
  void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo);
}

public class PictureStorage implements IPictureStorage {

  @Override
  public void savePicture(Picture picture) { ... }
  @Override
  public Image getPicture(String pictureId) { ... }
  @Override
  public void deletePicture(String pictureId) { ... }
  @Override
  public void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo) { ... }
}
```

我们利用 java 中的 interface 接口语法来实现抽象特性, 调用者在使用图片存储功能的时候，只需要了解 IPictureStorage 这个接口类暴露了哪些方法就可以了，不需要去查看 PictureStorage 类里的具体实现逻辑

实际上，抽象这个特性是非常容易实现的，并不需要非得依靠接口类或者抽象类这些特殊语法机制来支持。换句话说，并不是说一定要为实现类（PictureStorage）抽象出接口类（IPictureStorage），才叫作抽象。即便不编写 IPictureStorage 接口类，单纯的 PictureStorage 类本身就满足抽象特性

那是因为，类的方法是通过编程语言中的`函数`这一语法机制来实现的。通过函数包裹具体的实现逻辑，这本身就是一种抽象。调用者在使用函数的时候，并不需要去研究函数内部的实现逻辑，只需要通过函数的命名、注释或者文档，了解其提供了什么功能，就可以直接使用了。比如，我们在使用 C 语言的 `malloc()` 函数的时候，并不需要了解它的底层代码是怎么实现的**

**函数本身就是一种抽象**


抽象这个概念是一个非常通用的设计思想，并不单单用在面向对象编程中，也可以用来指导架构设计等。而且这个特性也并不需要编程语言提供特殊的语法机制来支持，只需要提供**函数**这一非常基础的语法机制，就可以实现抽象特性，有时并不被看作面向对象编程的特性之一


### 继承

继承是用来表示类之间的 `is-a` 关系【猫是一种哺乳动物】

继承可以分为 **单继承和多继承**，单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类【猫既是哺乳动物，又是爬行动物】


继承最大的好处就是 **代码复用**, 【假如两个类有一些相同的属性和方法，我们就可以将这些相同的部分，抽取到父类中，让两个子类继承父类。这样，两个子类就可以重用父类中的代码，避免代码重复写多遍】


### 多态

多态: 事物在运行过程中存在不同的状态【子类可以替换父类，在实际的代码运行中，调用子类的方法实现】

```
public class DynamicArray {
  private static final int DEFAULT_CAPACITY = 10;
  protected int size = 0;
  protected int capacity = DEFAULT_CAPACITY;
  protected Integer[] elements = new Integer[DEFAULT_CAPACITY];
  
  public int size() { return this.size; }
  public Integer get(int index) { return elements[index];}
  
  public void add(Integer e) {
    ensureCapacity();
    elements[size++] = e;
  }
  
  protected void ensureCapacity() {
    ...
  }
}

public class SortedDynamicArray extends DynamicArray {
  @Override
  public void add(Integer e) {
    ensureCapacity();
    int i;
    for (i = size-1; i>=0; --i) {
      if (elements[i] > e) {
        elements[i+1] = elements[i];
      } else {
        break;
      }
    }
    elements[i+1] = e;
    ++size;
  }
}

public class Example {
  public static void test(DynamicArray dynamicArray) {
    dynamicArray.add(5);
    dynamicArray.add(1);
    dynamicArray.add(3);
    for (int i = 0; i < dynamicArray.size(); ++i) {
      System.out.println(dynamicArray.get(i));
    }
  }
  
  public static void main(String args[]) {
    DynamicArray dynamicArray = new SortedDynamicArray();
    test(dynamicArray); // 打印结果：1、3、5
  }
}
```

对于多态特性的实现方式，除了利用**继承加方法重写**这种实现方式之外，我们还有其他两种比较常见的的实现方式，**一个是利用接口类语法，另一个是利用 duck-typing 语法**


#### 利用接口类实现多态

```
public interface Iterator {
  boolean hasNext();
  String next();
  String remove();
}

public class Array implements Iterator {
  private String[] data;
  
  public boolean hasNext() { ... }
  public String next() { ... }
  public String remove() { ... }
}

public class LinkedList implements Iterator {
  private LinkedListNode head;
  
  public boolean hasNext() { ... }
  public String next() { ... }
  public String remove() { ... }
}

public class Demo {
  private static void print(Iterator iterator) {
    while (iterator.hasNext()) {
      System.out.println(iterator.next());
    }
  }
  
  public static void main(String[] args) {
    Iterator arrayIterator = new Array();
    print(arrayIterator);
    
    Iterator linkedListIterator = new LinkedList();
    print(linkedListIterator);
  }
}
```

`Iterator` 是一个接口类，定义了一个可以遍历集合数据的迭代器。`Array` 和 `LinkedList` 都实现了接口类 `Iterator`。我们通过传递不同类型的实现类（`Array、LinkedList`）到 `print(Iterator iterator)` 函数中，支持动态的调用不同的 `next()、hasNext()` 实现


#### 利用 duck-typing 来实现多态

duck-typing 鸭子类型, 在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由**当前方法和属性的集合**决定


**当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子**


**在鸭子类型中，关注点在于对象的行为，能作什么；而不是关注对象所属的类型**


在常规类型中，我们能否在一个特定场景中使用某个对象取决于这个对象的类型，而在鸭子类型中，则取决于这个对象是否具有某种属性或者方法,**即只要具备特定的属性或方法，能通过鸭子测试，就可以使用**

```
class Logger:
    def record(self):
        print(“I write a log into file.”)
        
class DB:
    def record(self):
        print(“I insert data into db. ”)
        
def test(recorder):
    recorder.record()

def demo():
    logger = Logger()
    db = DB()
    test(logger)
    test(db)
```

Logger 和 DB 两个类没有任何关系，既不是继承关系，也不是接口和实现的关系，但是只要它们都有定义了 record() 方法，就可以被传递到 test() 方法中，在实际运行的时候，执行对应的 record() 方法


**多态特性能提高代码的可扩展性和复用性**


