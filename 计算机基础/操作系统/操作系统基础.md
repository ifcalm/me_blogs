## 操作系统

### 操作系统的演进

1. 无操作系统
   - 人工操作
   - 用户独占
   - CPU 等待人工操作
   - 资源利用率很低

2. 批处理系统
   - 无需等待人工操作
   - 批量输入任务
   - 资源利用率提升
   - 多道程序设计

3. 分时系统
   - 人机交互
   - 多用户共享
   - 及时调试程序

多道程序设计

- 早期的批处理系统只能一次处理一个任务
- 多道程序设计使得批处理系统可以一次处理多个任务
- 多道程序设计是指在计算机内存中同时存放多个程序
- 多道程序在计算机的管理程序之下相互穿插运行
- 多道程序的管理是操作系统的重要功能

### 操作系统涉及的五大功能

1. 进程管理
   - 进程实体
   - 五种状态模型
   - 进程同步
   - Linux的进程管理
2. 存储管理
   - 内存分配与回收
   - 段页式存储管理
   - 虚拟内存
   - Linux的存储管理
3. 作业管理
   - 进程调度
   - 死锁
4. 文件管理
   - Linux 的文件系统
   - Linux文件的基本操作
5. 设备管理


### 操作系统概述
操作系统是管理硬件，提供用户交互的软件系统

操作系统可以看作是计算机硬件的一种抽象

#### 什么是操作系统

1. 操作系统是管理计算机硬件和软件资源的计算机程序
2. 管理配置内存，决定资源供需顺序，控制输入输出设备等
3. 操作系统提供让用户和系统交互的操作界面

#### 常见的操作系统
- Android
- IOS
- Windows
- Linux
- MacOS

#### 操作系统的基本功能

计算机的资源包括如下:
- 处理器资源
- 存储器资源
- IO 设备资源
- 文件资源

而操作系统统一管理着上述计算机资源

例如我们操作一个文件并不是直接去在磁盘上操作该文件，而是通过操作系统来进行操作的

有了操作系统之后，用户无需面向硬件接口编程，在操作系统中有 IO设备管理软件，由这些软件提供读写接口，供用户使用，而无需直接操作硬件

操作系统实现了对计算机资源的抽象

操作系统提供了用户与计算机之间的接口

- 图形窗口形式，windows常用
- 命令形式，Linux常用
- 系统调用形式，编程时常用


层次结构：用户--> 系统调用/命令/图形窗口--> 操作系统--> 计算机硬件

#### 操作系统相关概念

- 并发性
- 共享性
- 虚拟性
- 异步性

##### 并发性
并行 VS 并发

- 并行是指两个或多个时间可以在**同一时刻**发生
- 并发是指两个或者多个时间可以在**同一个时间间隔**发生


在单处理器上多道程序交替运行，程序并发执行

在多处理器上不同程序可以分别在不同的处理器上并行执行，在某一个处理器上也并发执行

##### 共享性

共享性表现为操作系统中的资源可供多个并发的程序共同使用，这种共同使用的形式称之为资源共享

互斥共享资源：
当共享资源被进程A占用时，其他想使用该资源的只能等待，只有进程A使用完以后，其他进程才可以使用该资源


同时共享资源：
某种资源在一段时间内并发的被多个进程访问，这种同时是宏观的，从宏观上看该资源可以被同时访问

##### 虚拟性

虚拟性表现为把一个物理实体转变位若干个逻辑实体，物理实体是真实存在的，逻辑实体是虚拟的

虚拟的技术主要有**时分复用技术**和**空分复用技术**

时分复用技术：
资源在时间上进行复用，不同程序并发使用，多道程序分时使用计算机的硬件资源，提高资源利用率

- 虚拟处理器技术：借助多道程序设计技术，为每个程序建立进程，多个进程分时复用处理器

- 虚拟设备技术：物理设备虚拟为多个逻辑设备，每个程序占用一个逻辑设备，多个程序通过逻辑设备并发访问

空分复用技术：空分复用技术用来实现虚拟磁盘，虚拟内存的

- 虚拟磁盘技术：物理磁盘虚拟为逻辑磁盘，比如一个物理磁盘被划分为 C，D，D 等逻辑盘，使用起来更加安全，方便
- 虚拟内存技术：在逻辑上扩大程序的存储容量，使用比实际内存更大的容量，大大提升编程效率


##### 异步性

在多道程序环境下，允许多个进程并发执行，进程在使用资源时可能需要等待或放弃，进程的执行并不是一气呵成的，而是以走走停停的形式推进


-----------------------------------------


### 进程管理

#### 进程实体

操作系统的主要功能就是管理计算机的硬件资源，比如处理器资源，存储器资源，IO设备资源，文件资源等，没有配置OS之前，资源属于当前运行的程序，当程序在使用处理器资源的时候，其他资源是空闲的，为了提供资源利用率，就引入了多道程序涉及的概念，OS出现之后，进程就出现了，进程的主要功能是合理的隔离资源，运行环境，提升资源利用率

- 进程是系统进行资源分配和调度的基本单位，引入多道程序涉及之后，操作系统就可以为每个进程进行资源分配了

- 进程作为程序独立运行的载体保障程序正常执行

- 进程的存在使得操作系统资源的利用率大幅提升


##### 主存中的进程形态

在主存中进程是一段连续的存储空间，这个空间称之为**进程控制块**

进程控制块中的信息:

- 标识符，标识符唯一标记一个进程，用于区别其他进程
- 状态，标记进程的进程状态，如 运行态
- 优先级，
- 程序计数器，指向进程即将被执行的下一条指令的地址
- 内存指针，程序代码，进程数据相关指针
- 上下文数据，进程执行时处理器存储的数据
- IO状态信息，被进行IO操作所占用的文件列表
- 记账信息，使用处理器时间，时钟数总和等

以上进程控制块可以分为4类:
1. 进程标识符
2. 处理机状态
3. 进程调度信息
4. 进程控制信息

#### 进程控制块(PCB)

用于描述和控制进程运行的通用数据结构，记录进程当前状态和控制进程运行的全部信息，PCB 使得进程是能够独立运行的基本单位

PCB 是操作系统进行调度经常会被读取的信息，他是常驻内存的，存放在系统专门开辟的PCB区域内

#### 进程与线程

- 进程，Process
- 线程，Thread

一个进程可以有一个或多个线程


线程是操作系统进行运行调度的最小单位，进程是系统进行资源分配和调度的基本单位

操作系统对进程的调度实际上是对进程内线程的调度，线程包含在进程之中，是进程中实际运行工作的单位

一个进程可以并发多个线程，每个线程执行不同的任务

进程中的线程共享进程资源

类别|进行|线程
:--:|:--:|:--:
资源|资源分配的基本单位|不拥有资源
调度|独立调度的基本单位|独立调度的最小单位
系统开销|进程开销大|线程开销小
通信|进程IPC|读写同一进程数据通信


-------------------------

### 进程的五种状态模型

- 创建，创建进程时拥有PCB但其他资源尚未就绪的状态称为 创建状态，操作系统提供了 fork 函数创建进程
- 就绪，其他资源都准备好了，只差CPU资源的状态称为 就绪状态，在一个系统中多个处于就绪状态的进程通常排除一个队列，称为就绪队列
- 阻塞，进程因为某种原因，如其他设备未就绪而无法继续执行，从而放弃CPU的状态称为 阻塞状态，多个阻塞进程会形成一个阻塞队列
- 执行，进程获得CPU，其程序正在执行称为 执行状态，在单处理机中，在某个时刻只能有一个进程是处于执行状态
- 终止，进程结束由系统清理或归还 PCB 的状态称为 终止状态

状态之间的切换:

- 就绪--> 执行
- 执行--> 就绪
- 执行--> 阻塞
- 阻塞--> 就绪


----------------------------------

### 进程同步

#### 生产者-消费者问题

生产者消费者问题（Producer-consumer problem），也称有限缓冲问题（Bounded-buffer problem），是一个多进程同步问题的经典案例。该问题描述了共享固定大小缓冲区的两个进程，即所谓的生产者和消费者，在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据

要解决该问题，就必须让生产者在缓冲区满时休眠，等到下次消费者消耗缓冲区中的数据的时候，生产者才能被唤醒，开始往缓冲区添加数据。同样，也可以让消费者在缓冲区空时进入休眠，等到生产者往缓冲区添加数据之后，再唤醒消费者。通常采用进程间通信的方法解决该问题，常用的方法有信号灯法等。如果解决方法不够完善，则容易出现死锁的情况。出现死锁时，两个线程都会陷入休眠，等待对方唤醒自己。该问题也能被推广到多个生产者和消费者的情形

但是两者并发执行时就可能出差错

#### 哲学家进餐问题

哲学家就餐问题是在计算机科学中的一个经典问题，用来演示在并发计算中多线程同步时产生的问题，这个问题可以用来解释死锁和资源耗尽

哲学家就餐问题可以这样表述，假设有五位哲学家围坐在一张圆形餐桌旁，做以下两件事情之一：吃饭，或者思考。吃东西的时候，他们就停止思考，思考的时候也停止吃东西。餐桌中间有一大碗意大利面，每位哲学家之间各有一只餐叉。因为用一只餐叉很难吃到意大利面，所以假设哲学家必须用两只餐叉吃东西。他们只能使用自己左右手边的那两只餐叉。哲学家就餐问题有时也用米饭和五根筷子而不是意大利面和餐叉来描述，因为吃米饭必须用两根筷子

这个问题不考虑意大利面有多少，也不考虑哲学家的胃有多大。假设两者都是无限大

问题在于如何设计一套规则，使得在哲学家们在完全不交谈，也就是无法知道其他人可能在什么时候要吃饭或者思考的情况下，可以在这两种状态下永远交替下去

这个问题旨在说明避免死锁的挑战，死锁是一种程序无法继续运行的状态。要更好理解这个问题，假设我们要求哲学家遵守以下规则：

1. 哲学家在左边的叉子可用（没有其他人拿起）之前处于思考状态。如果左边的叉子可用，就拿起来
2. 哲学家等待右边的叉子可用。如果右边的叉子可用，就拿起来
3. 如果两个叉子都已经拿起来，开始吃意大利面，每次吃面都花费同样的时间
4. 吃完后先放下左边的叉子
5. 然后放下右边的叉子
6. 开始思考（进入一个循环）

这个解法是失败的，当每个哲学家都拿起左侧的叉子，等待右侧的叉子可用时，就会进入死锁状态，每个哲学家将永远都在等待（右边的）另一个哲学家放下叉子

如果特定的哲学家由于时间问题而无法同时获得两个资源，那么资源匮乏也可能独立于死锁而发生。例如，假设规定当哲学家等待另一只餐叉超过五分钟后就放下自己手里的那一只餐叉，并且再等五分钟后进行下一次尝试。这个策略消除了死锁（系统总会进入到下一个状态），但仍然有可能发生“活锁”。如果五位哲学家在完全相同的时刻进入餐厅，并同时拿起左边的餐叉，那么这些哲学家就会等待五分钟，同时放下手中的餐叉，再等五分钟，又同时拿起这些餐叉

互斥是此问题的基本概念。在实际的计算机问题中，缺乏餐叉可以类比为缺乏共享资源。一种常用的计算机技术是资源加锁，用来保证在某个时刻，资源只能被一个程序或一段代码访问。当一个程序想要使用的资源已经被另一个程序锁定，它就等待资源解锁。当多个程序涉及到加锁的资源时，在某些情况下就有可能发生死锁。例如，某个程序需要访问两个文件，当两个这样的程序各锁了一个文件，那它们都在等待对方解锁另一个文件，而解锁永远不会发生


以上两个问题的根源是：彼此之间没有通信

进程间的同步 对竞争资源在多进程间进行使用次序的协调，使得并发执行的多个进程之间可以有效使用资源和相互合作

#### 进程间同步的原则

1. 资源没有占用，允许使用
2. 资源有占用，请求进程等待
3. 保证有限等待时间能够使用资源
4. 等待时，进程需要让出 CPU

##### 临界资源:
多道程序系统中存在许多进程，它们共享各种资源，然而有很多资源一次只能供一个进程使用。一次仅允许一个进程使用的资源称为临界资源。许多物理设备都属于临界资源，如输入机、打印机、磁带机等

各进程采取互斥的方式，实现共享的资源称作临界资源


#### 进程间同步使用的方法

1. 消息队列
2. 共享存储
3. 信号量


进程内的多线程也需要同步

#### 线程间同步的方法

1. 互斥量
2. 读写锁
3. 自旋锁
4. 条件变量

-------------------------------

### Linux 的进程管理

#### 进程的类型

- 前台进程，具有终端，可以和用户交互的进程
- 后台进程，没有占用终端的就是后台进程
- 守护进程，是一种特殊的后台进程，随着系统的启动而启动，一直运行直到系统关闭，Linux中以 d 结尾的一般都是守护进程

#### 进程的标记
 - 进程 ID，是进程的唯一标记，每个进程拥有不同的 ID
 - 进程的状态标记

#### 进程的层级关系

进程A调用 fork 函数创建了进程 B， 进程B 调用fork函数创建了进程C，那么进程A 就是进程B 的父进程

进程的层级关系可以通过 `pstree` 命令来查看

ID为 0 的进程为 idle 进程，是系统创建的第一个进程

ID 为 1 的进程为 init 进程，是 0 号进程的子进程，完成系统初始化

init 进程是所有用户进程的祖先进程

#### 操作Linux进程的相关命令

- ps
- top
- kill

-------------------------------------

### 作业管理---进程调度

