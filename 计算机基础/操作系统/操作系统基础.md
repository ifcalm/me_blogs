## 操作系统

### 操作系统的演进

1. 无操作系统
   - 人工操作
   - 用户独占
   - CPU 等待人工操作
   - 资源利用率很低

2. 批处理系统
   - 无需等待人工操作
   - 批量输入任务
   - 资源利用率提升
   - 多道程序设计

3. 分时系统
   - 人机交互
   - 多用户共享
   - 及时调试程序

多道程序设计

- 早期的批处理系统只能一次处理一个任务
- 多道程序设计使得批处理系统可以一次处理多个任务
- 多道程序设计是指在计算机内存中同时存放多个程序
- 多道程序在计算机的管理程序之下相互穿插运行
- 多道程序的管理是操作系统的重要功能

### 操作系统涉及的五大功能

1. 进程管理
   - 进程实体
   - 五种状态模型
   - 进程同步
   - Linux的进程管理
2. 存储管理
   - 内存分配与回收
   - 段页式存储管理
   - 虚拟内存
   - Linux的存储管理
3. 作业管理
   - 进程调度
   - 死锁
4. 文件管理
   - Linux 的文件系统
   - Linux文件的基本操作
5. 设备管理


### 操作系统概述
操作系统是管理硬件，提供用户交互的软件系统

操作系统可以看作是计算机硬件的一种抽象

#### 什么是操作系统

1. 操作系统是管理计算机硬件和软件资源的计算机程序
2. 管理配置内存，决定资源供需顺序，控制输入输出设备等
3. 操作系统提供让用户和系统交互的操作界面

#### 常见的操作系统
- Android
- IOS
- Windows
- Linux
- MacOS

#### 操作系统的基本功能

计算机的资源包括如下:
- 处理器资源
- 存储器资源
- IO 设备资源
- 文件资源

而操作系统统一管理着上述计算机资源

例如我们操作一个文件并不是直接去在磁盘上操作该文件，而是通过操作系统来进行操作的

有了操作系统之后，用户无需面向硬件接口编程，在操作系统中有 IO设备管理软件，由这些软件提供读写接口，供用户使用，而无需直接操作硬件

操作系统实现了对计算机资源的抽象

操作系统提供了用户与计算机之间的接口

- 图形窗口形式，windows常用
- 命令形式，Linux常用
- 系统调用形式，编程时常用


层次结构：用户--> 系统调用/命令/图形窗口--> 操作系统--> 计算机硬件

#### 操作系统相关概念

- 并发性
- 共享性
- 虚拟性
- 异步性

##### 并发性
并行 VS 并发

- 并行是指两个或多个时间可以在**同一时刻**发生
- 并发是指两个或者多个时间可以在**同一个时间间隔**发生


在单处理器上多道程序交替运行，程序并发执行

在多处理器上不同程序可以分别在不同的处理器上并行执行，在某一个处理器上也并发执行

##### 共享性

共享性表现为操作系统中的资源可供多个并发的程序共同使用，这种共同使用的形式称之为资源共享

互斥共享资源：
当共享资源被进程A占用时，其他想使用该资源的只能等待，只有进程A使用完以后，其他进程才可以使用该资源


同时共享资源：
某种资源在一段时间内并发的被多个进程访问，这种同时是宏观的，从宏观上看该资源可以被同时访问

##### 虚拟性

虚拟性表现为把一个物理实体转变位若干个逻辑实体，物理实体是真实存在的，逻辑实体是虚拟的

虚拟的技术主要有**时分复用技术**和**空分复用技术**

时分复用技术：
资源在时间上进行复用，不同程序并发使用，多道程序分时使用计算机的硬件资源，提高资源利用率

- 虚拟处理器技术：借助多道程序设计技术，为每个程序建立进程，多个进程分时复用处理器

- 虚拟设备技术：物理设备虚拟为多个逻辑设备，每个程序占用一个逻辑设备，多个程序通过逻辑设备并发访问

空分复用技术：空分复用技术用来实现虚拟磁盘，虚拟内存的

- 虚拟磁盘技术：物理磁盘虚拟为逻辑磁盘，比如一个物理磁盘被划分为 C，D，D 等逻辑盘，使用起来更加安全，方便
- 虚拟内存技术：在逻辑上扩大程序的存储容量，使用比实际内存更大的容量，大大提升编程效率


##### 异步性

在多道程序环境下，允许多个进程并发执行，进程在使用资源时可能需要等待或放弃，进程的执行并不是一气呵成的，而是以走走停停的形式推进


-----------------------------------------


### 进程管理

#### 进程实体

操作系统的主要功能就是管理计算机的硬件资源，比如处理器资源，存储器资源，IO设备资源，文件资源等，没有配置OS之前，资源属于当前运行的程序，当程序在使用处理器资源的时候，其他资源是空闲的，为了提供资源利用率，就引入了多道程序涉及的概念，OS出现之后，进程就出现了，进程的主要功能是合理的隔离资源，运行环境，提升资源利用率

- 进程是系统进行资源分配和调度的基本单位，引入多道程序涉及之后，操作系统就可以为每个进程进行资源分配了

- 进程作为程序独立运行的载体保障程序正常执行

- 进程的存在使得操作系统资源的利用率大幅提升


##### 主存中的进程形态

在主存中进程是一段连续的存储空间，这个空间称之为**进程控制块**

进程控制块中的信息:

- 标识符，标识符唯一标记一个进程，用于区别其他进程
- 状态，标记进程的进程状态，如 运行态
- 优先级，
- 程序计数器，指向进程即将被执行的下一条指令的地址
- 内存指针，程序代码，进程数据相关指针
- 上下文数据，进程执行时处理器存储的数据
- IO状态信息，被进行IO操作所占用的文件列表
- 记账信息，使用处理器时间，时钟数总和等

以上进程控制块可以分为4类:
1. 进程标识符
2. 处理机状态
3. 进程调度信息
4. 进程控制信息

#### 进程控制块(PCB)

用于描述和控制进程运行的通用数据结构，记录进程当前状态和控制进程运行的全部信息，PCB 使得进程是能够独立运行的基本单位

PCB 是操作系统进行调度经常会被读取的信息，他是常驻内存的，存放在系统专门开辟的PCB区域内

#### 进程与线程

- 进程，Process
- 线程，Thread

一个进程可以有一个或多个线程


线程是操作系统进行运行调度的最小单位，进程是系统进行资源分配和调度的基本单位

操作系统对进程的调度实际上是对进程内线程的调度，线程包含在进程之中，是进程中实际运行工作的单位

一个进程可以并发多个线程，每个线程执行不同的任务

进程中的线程共享进程资源

类别|进行|线程
:--:|:--:|:--:
资源|资源分配的基本单位|不拥有资源
调度|独立调度的基本单位|独立调度的最小单位
系统开销|进程开销大|线程开销小
通信|进程IPC|读写同一进程数据通信


-------------------------

### 进程的五种状态模型

- 创建，创建进程时拥有PCB但其他资源尚未就绪的状态称为 创建状态，操作系统提供了 fork 函数创建进程
- 就绪，其他资源都准备好了，只差CPU资源的状态称为 就绪状态，在一个系统中多个处于就绪状态的进程通常排除一个队列，称为就绪队列
- 阻塞，进程因为某种原因，如其他设备未就绪而无法继续执行，从而放弃CPU的状态称为 阻塞状态，多个阻塞进程会形成一个阻塞队列
- 执行，进程获得CPU，其程序正在执行称为 执行状态，在单处理机中，在某个时刻只能有一个进程是处于执行状态
- 终止，进程结束由系统清理或归还 PCB 的状态称为 终止状态

状态之间的切换:

- 就绪--> 执行
- 执行--> 就绪
- 执行--> 阻塞
- 阻塞--> 就绪


----------------------------------

### 进程同步

#### 生产者-消费者问题

生产者消费者问题（Producer-consumer problem），也称有限缓冲问题（Bounded-buffer problem），是一个多进程同步问题的经典案例。该问题描述了共享固定大小缓冲区的两个进程，即所谓的生产者和消费者，在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据

要解决该问题，就必须让生产者在缓冲区满时休眠，等到下次消费者消耗缓冲区中的数据的时候，生产者才能被唤醒，开始往缓冲区添加数据。同样，也可以让消费者在缓冲区空时进入休眠，等到生产者往缓冲区添加数据之后，再唤醒消费者。通常采用进程间通信的方法解决该问题，常用的方法有信号灯法等。如果解决方法不够完善，则容易出现死锁的情况。出现死锁时，两个线程都会陷入休眠，等待对方唤醒自己。该问题也能被推广到多个生产者和消费者的情形

但是两者并发执行时就可能出差错

#### 哲学家进餐问题

哲学家就餐问题是在计算机科学中的一个经典问题，用来演示在并发计算中多线程同步时产生的问题，这个问题可以用来解释死锁和资源耗尽

哲学家就餐问题可以这样表述，假设有五位哲学家围坐在一张圆形餐桌旁，做以下两件事情之一：吃饭，或者思考。吃东西的时候，他们就停止思考，思考的时候也停止吃东西。餐桌中间有一大碗意大利面，每位哲学家之间各有一只餐叉。因为用一只餐叉很难吃到意大利面，所以假设哲学家必须用两只餐叉吃东西。他们只能使用自己左右手边的那两只餐叉。哲学家就餐问题有时也用米饭和五根筷子而不是意大利面和餐叉来描述，因为吃米饭必须用两根筷子

这个问题不考虑意大利面有多少，也不考虑哲学家的胃有多大。假设两者都是无限大

问题在于如何设计一套规则，使得在哲学家们在完全不交谈，也就是无法知道其他人可能在什么时候要吃饭或者思考的情况下，可以在这两种状态下永远交替下去

这个问题旨在说明避免死锁的挑战，死锁是一种程序无法继续运行的状态。要更好理解这个问题，假设我们要求哲学家遵守以下规则：

1. 哲学家在左边的叉子可用（没有其他人拿起）之前处于思考状态。如果左边的叉子可用，就拿起来
2. 哲学家等待右边的叉子可用。如果右边的叉子可用，就拿起来
3. 如果两个叉子都已经拿起来，开始吃意大利面，每次吃面都花费同样的时间
4. 吃完后先放下左边的叉子
5. 然后放下右边的叉子
6. 开始思考（进入一个循环）

这个解法是失败的，当每个哲学家都拿起左侧的叉子，等待右侧的叉子可用时，就会进入死锁状态，每个哲学家将永远都在等待（右边的）另一个哲学家放下叉子

如果特定的哲学家由于时间问题而无法同时获得两个资源，那么资源匮乏也可能独立于死锁而发生。例如，假设规定当哲学家等待另一只餐叉超过五分钟后就放下自己手里的那一只餐叉，并且再等五分钟后进行下一次尝试。这个策略消除了死锁（系统总会进入到下一个状态），但仍然有可能发生“活锁”。如果五位哲学家在完全相同的时刻进入餐厅，并同时拿起左边的餐叉，那么这些哲学家就会等待五分钟，同时放下手中的餐叉，再等五分钟，又同时拿起这些餐叉

互斥是此问题的基本概念。在实际的计算机问题中，缺乏餐叉可以类比为缺乏共享资源。一种常用的计算机技术是资源加锁，用来保证在某个时刻，资源只能被一个程序或一段代码访问。当一个程序想要使用的资源已经被另一个程序锁定，它就等待资源解锁。当多个程序涉及到加锁的资源时，在某些情况下就有可能发生死锁。例如，某个程序需要访问两个文件，当两个这样的程序各锁了一个文件，那它们都在等待对方解锁另一个文件，而解锁永远不会发生


以上两个问题的根源是：彼此之间没有通信

进程间的同步 对竞争资源在多进程间进行使用次序的协调，使得并发执行的多个进程之间可以有效使用资源和相互合作

#### 进程间同步的原则

1. 资源没有占用，允许使用
2. 资源有占用，请求进程等待
3. 保证有限等待时间能够使用资源
4. 等待时，进程需要让出 CPU

##### 临界资源:
多道程序系统中存在许多进程，它们共享各种资源，然而有很多资源一次只能供一个进程使用。一次仅允许一个进程使用的资源称为临界资源。许多物理设备都属于临界资源，如输入机、打印机、磁带机等

各进程采取互斥的方式，实现共享的资源称作临界资源


#### 进程间同步使用的方法

1. 消息队列
2. 共享存储
3. 信号量


进程内的多线程也需要同步

#### 线程间同步的方法

1. 互斥量
2. 读写锁
3. 自旋锁
4. 条件变量

-------------------------------

### Linux 的进程管理

#### 进程的类型

- 前台进程，具有终端，可以和用户交互的进程
- 后台进程，没有占用终端的就是后台进程
- 守护进程，是一种特殊的后台进程，随着系统的启动而启动，一直运行直到系统关闭，Linux中以 d 结尾的一般都是守护进程

#### 进程的标记
 - 进程 ID，是进程的唯一标记，每个进程拥有不同的 ID
 - 进程的状态标记

#### 进程的层级关系

进程A调用 fork 函数创建了进程 B， 进程B 调用fork函数创建了进程C，那么进程A 就是进程B 的父进程

进程的层级关系可以通过 `pstree` 命令来查看

ID为 0 的进程为 idle 进程，是系统创建的第一个进程

ID 为 1 的进程为 init 进程，是 0 号进程的子进程，完成系统初始化

init 进程是所有用户进程的祖先进程

#### 操作Linux进程的相关命令

- ps
- top
- kill

-------------------------------------

### 作业管理---进程调度

进程调度是指计算机通过决策决定哪个就绪进程可以获得CPU使用权

进程调度需要保留旧进程的运行信息，请出旧进程，选择新进程，准备运行环境并分配CPU

进程调度涉及的三种机制:

- 就绪队列的排队机制，将就绪进程按照一定的方式排成队列，以便调度程序可以最快找到就绪进程
- 选择运行进程的委派机制，调度程序以一定的策略选择就绪进程，将CPU资源分配给它
- 新老进程的上下文切换机制，保存当前进程的上下文信息，装入被委派执行进程的运行上下文

#### 非抢占式的调度和抢占式的调度

- 非抢占式调度，处理器一旦分配给某个进程，就让该进程一直使用下去，调度程序不以任何原因抢占正在被使用的处理器，直到进程完成工作或因为IO阻塞才会让出处理器
- 抢占式调度，允许调度程序以一定的策略暂停当前运行的进程，保存好旧进程的上下文信息，分配处理器给新进程

类别|抢占式调度|非抢占式调度
:--:|:--:|:--:
系统开销|频繁切换，开销大|切换次数小，开销小
公平性|相对公平|不公平
应用|通用系统|专用系统


#### 进程调度算法

- 先来先服务调度算法
- 短进程优先服务算法，调度程序优先选择就绪队列中估计运行时间最短的进程，不利于长作业进程的执行
- 高优先权优先调度算法，进程附带优先权，调度程序优先选择权重高的进程，使得紧迫的任务可以优先处理
- 时间片轮转调度算法，按先来先服务的原则排列就绪进程，每次从队列头部取出待执行进程，分配一个时间片执行，这个一个相对公平的调度算法，但不能保证及时响应用户


---------------------------------------

### 作业管理之死锁

死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者彼此通信而造成的一种阻塞现象，若无外力作用，它们都将无法推进下去，此时系统处于死锁状态，这些永远在互相等待的进程称为死锁进程


- 死锁的产生
- 死锁的处理

#### 死锁的产生

- 竞争资源，共享资源数量不满足各个进程需求，各个进程之间发生资源竞争而导致死锁
- 进程调度顺序不当


死锁产生的四个条件:

- 互斥条件，进程对资源的使用是排他性的使用，某资源只能由一个进程使用，其他进程需要使用只能等待释放
- 请求保持条件, 进程至少保持一个资源，又提出新的资源请求，而新资源被占用，请求被阻塞，被阻塞的进程不释放自己保持的资源
- 不可剥夺条件，进程获得的资源在未完成使用前不能被剥夺，该资源只能由进程自身释放
- 环路等待条件，发生死锁时，必然存在进程-资源 环形链

#### 死锁的处理

破坏死锁产生的条件即可

##### 银行家算法

银行家算法是一个避免死锁（Deadlock）的著名算法，是由艾兹格·迪杰斯特拉在1965年为T.H.E系统设计的一种避免死锁产生的算法。它以银行借贷系统的分配策略为基础，判断并保证系统的安全运行

在银行中，客户申请贷款的数量是有限的，每个客户在第一次申请贷款时要声明完成该项目所需的最大资金量，在满足所有贷款要求时，客户应及时归还。银行家在客户申请的贷款数量不超过自己拥有的最大值时，都应尽量满足客户的需要。在这样的描述中，银行家就好比操作系统，资金就是资源，客户就相当于要申请资源的进程


------------------------------------

### 内存管理---内存分配与回收

早期计算机编程并不需要过多的存储管理，随着计算机和程序越来越复杂，存储管理成为必要，存储管理主要解决如下几个问题:

- 确保计算机有足够的内存处理数据
- 确保程序可以从可用内存中获取一部分内存使用
- 确保程序可以归还使用后的内存以供其他程序使用


#### 内存分配的过程

- 单一连续分配是最简单的内存分配方式，只能在单用户，单进程的操作系统中使用
- 固定分区分配是支持多道程序的最简单的存储分配方式，内存空间被划分为若干个固定大小的区域，每个分区只提供给一个进程使用，互不干扰
- 根据进程实际需要，动态分配内存空间，这个操作系统常用的方法，涉及相关的数据结构和分配算法


##### 动态分配内存空间:

- 动态分区空闲表数据结构
- 动态分区空闲链数据结构---链表
- 首次适应算法(FF算法)，分配内存空间时从开始顺序查找适合内存区，若没有合适的空闲区，则该次分配失败
- 最佳适应算法(BF算法)，要求空闲区链表按照容量大小排序，遍历空闲区链表找到最佳合适空闲区
- 快速适应算法(QF算法)，要求有多个空闲区链表，每个空闲区链表存储一种容量的空闲区


##### 内存回收的过程:

- 需要回收的区域与一块空闲区连在一起，并在空闲区后面，这种情况不需要新建空闲链表节点，直接与上面的空闲区合并就好
- 需要回收的区域与一块空闲区连在一起，并在空闲区前面，这种情况将回收区与空闲区合并，新的空闲区使用回收区的地址
- 需要回收的区域位于两块空闲区之间，将三个区域合并，新形成的空闲区使用最前面空闲区的地址
- 需要回收的区域是单一的，没有连接任何空闲区，这种情况为回收区创建新的空闲节点，插入到相应的空闲区链表中去


-----------------------------------------

### 存储管理之段页式存储管理

操作系统是如何管理进程的空间？

- 页式存储管理
- 段式存储管理
- 段页式存储管理

#### 页式存储管理

将进程逻辑空间等分成若干大小的页面，相应的把物理内存空间分成与页面大小的物理块，以页面为单位把进程空间装进物理内存中分散的物理块

页面大小应该适中，过大难以分配，过小**内存碎片**过多

**页表**记录进程逻辑空间与物理空间的映射

当有一段连续的逻辑分布在多个页面中时，将大大降低执行效率

#### 段式存储管理

将进程逻辑空间划分为非等分的若干段，段的长度由连续逻辑的长度决定

**段表**记录进程逻辑空间与物理地址的映射


段式存储和页式存储都离散的管理了进程的逻辑空间

#### 段页式存储管理

段式存储和页式存储两者结合，形成段页式存储管理


-------------------------

### 存储管理之虚拟内存

一个游戏10G，物理内存只有4G，那这个游戏是怎么运行起来的？

- 虚拟内存
- 程序的局部性原理
- 虚拟内存的置换算法


有些进程实际需要的内存很大，超过物理内存的容量，而多道程序设计的普及，使得每个进程可用物理内存更加稀缺，但事实上又不可能无限增加物理内存，所以物理内存总有不够的时候

虚拟内存是操作系统内存管理的关键技术，使得多道程序运行个大程序运行成为现实，把程序使用内存划分，将暂时不使用的内存放置在辅存

#### 程序的局部性原理

局部性原理是指CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中，所以程序运行时，无需全部装入内存，装载部分即可，如果访问页不存在，则发出缺页中断，发起页面置换，从用户层面看，程序拥有很大的空间，即是虚拟内存


虚拟内存是对物理内存的补充，速度接近于内存，成本接近于辅存


#### 虚拟内存的置换算法

- 先进先出算法(FIFO)
- 最不经常使用算法(LFU)
- 最近最少使用算法(LRU)


----------------------------------------

### Linux 的存储管理

- Buddy 内存管理算法，计算机算法的一种，是为了核心内存管理能够快速响应请求，尽可能地在提高内存利用率的同时减少**内存碎片**的一种算法
- Linux 交换空间

#### Linux 交换空间

交换空间(swap)是磁盘的一个分区，Linux 物理内存满时，会把一些内存交换至swap空间，swap空间是初始化系统时配置的

swap空间|虚拟内
:--:|:--:
swap空间存在于磁盘|虚拟内存存在于磁盘
swap空间与主存发生置换|虚拟内存与主存发生置换
swap空间是操作系统概念|虚拟内存是进程概念
swap空间解决系统物理内存不足的问题|虚拟内存解决进程物理内存不足的问题


---------------------------------------

### 文件管理

- 文件的逻辑结构
- 辅存的存储空间分配
- 目录管理

#### 文件的逻辑结构

- 逻辑结构的文件类型，分为有结构文件和无结构文件，有结构文件包括文本文件，文档，媒体文件等，无结构文件(流式文件)有二进制文件，链接库等
- 顺序文件，按照顺序存储在存储介质中的文件，磁带的存储特性使得磁带文件只能存储顺序文件
- 索引文件，需要配合索引表完成存储的操作

#### 辅存的空间分配

- 连续分配
- 链接分配，显式链接和隐式链接
- 索引分配

-------------------------------

### Linux 文件的基本操作

- Linux目录介绍
- Linux文件的常用操作
- Linux文件类型

------------------------------------

### Linux的文件系统

- FAT
- NTFS
- EXT2/3/4

#### EXT文件系统

-----------------------------

### 设备管理

- 广义的IO设备
- IO设备的缓存区
- SPOOLing技术

对CPU而言，凡是对CPU进行数据输入的都是输入设备，对数据输出的都是输出设备

CPU与IO设备速率不匹配，IO设备的缓存区减少CPU处理IO请求的频率，提高CPU与IO设备之间的并行性

SPOOLing技术是低速输入输出设备与主机交换的一种技术

-----------------------------

### 线程同步，进程同步

保护临界资源，进行通信

线程间同步的方法: 互斥量，读写锁，自旋锁，条件遍历

进程间同步的方法：共享内存，域套接字

- 用户态与内核态
- 上下文切换
- 协程


#### 线程同步之互斥量

原子性，一些列操作不可被中断的特性

互斥量又称互斥锁，是线程同步的最简单方法，处于加锁或解锁状态，两个状态可以保证资源访问的串行

#### 线程同步之自旋锁

自旋锁也是一种多线程同步的变量，使用自旋锁的线程会反复检查锁变量是否可用，自旋锁不会让出CPU，是一种忙等待状态，即死循环等待锁被释放

自旋锁避免了进程或线程上下文切换的开销

#### 线程同步之读写锁

临界资源多读少写，读取的时候并不会改变临界资源的值

读写锁允许多个线程同时访问资源以提高读性能，但是对于写操作是互斥的

#### 线程同步之条件变量

条件变量允许线程睡眠，直到满足某种条件，当满足条件时，可以向该线程发生信号，通知唤醒

#### 使用 fork 系统调用 创建进程


------------------------

### 进程同步之共享内存

进程共享计算机资源

进行默认是不能访问进程空间之外的内存空间的

共享存储允许不相关的进程访问同一片物理内存，共享内存是两个进程之间共享和传递数据最快的方式


### 进程同步之Unix 域套接字

套接字(socket) 原是网络通信中使用的术语

Unix系统提供的域套接字提供了网络套接字类似的功能

----------------------------------

### 实现支持异步任务的线程池

