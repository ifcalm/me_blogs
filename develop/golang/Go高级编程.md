```
package main

import (
	"fmt"
	"log"
	"net/http"
	"time"
)

func main() {
	fmt.Println("Please visit http://127.0.0.1:12345/")
	http.HandleFunc("/", func(w http.ResponseWriter, req *http.Request) {
		s := fmt.Sprintf("你好，世界！, Time: %s", time.Now().String())
		fmt.Fprintf(w, "%v \n", s)
		log.Printf("%v \n", s)
	})

	if err := http.ListenAndServe(":12345", nil); err != nil {
		log.Fatal("ListenAndServe", err)
	}
}
```

## 数组-字符串-切片
在主流的编程语言中数组及其相关的数据结构是使用得最为频繁的，只有在它不能满足时才会考虑链表、散列表和更复杂的自定义数据结构

**散列表可以看作是数组和链表的混合体**

Go语言中数组、字符串和切片三者是密切相关的数据结构。这3种数据类型，在底层原始数据有着相同的内存结构，在上层，因为语法的限制而有着不同的行为表现

Go语言的数组是一种值类型，虽然数组的元素可以被修改，但是数组本身的赋值和函数传参都是以整体复制的方式处理的

Go语言字符串底层数据也是对应的字节数组，但是字符串的只读属性禁止了在程序中对底层字节数组的元素的修改

**字符串赋值只是复制了数据地址和对应的长度，而不会导致底层数据的复制**

切片的结构和字符串结构类似，但是解除了只读限制。切片的底层数据虽然也是对应数据类型的数组，但是每个切片还有独立的长度和容量信息，切片赋值和函数传参时也是将切片头信息部分按传值方式处理

**因为切片头含有底层数据的指针，所以它的赋值也不会导致底层数据的复制**

Go语言的赋值和函数传参规则很简单，除**闭包函数以引用的方式对外部变量访问之外**，其他赋值和函数传参都是以传值的方式处理


### 数组
数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。数组的长度是数组类型的组成部分

因为数组的长度是数组类型的一部分，不同长度或不同类型的数据组成的数组都是不同的类型

数组对应的类型是切片，切片是可以动态增长和收缩的序列，切片的功能也更加灵活

数组定义:
```
var a [3]int
var b [...]int{1, 2, 3}
var c [...]int{2: 3, 1: 2}   //元素为 0, 2, 3 (索引2对应的值为3)
var d [...]int{1, 2, 4: 5, 6} //元素为 1, 2, 0, 0, 5, 6
```
第一种方式是定义一个数组变量的最基本的方式，数组的长度明确指定，数组中的每个元素都以零值初始化

第二种方式是定义数组，可以在定义的时候顺序指定全部元素的初始化值，数组的长度根据初始化元素的数目自动计算

第三种方式是以索引的方式来初始化数组的元素，因此元素的初始化值出现顺序比较随意。这种初始化方式和`map[int]Type`类型的初始化语法类似。数组的长度以出现的最大的索引为准，没有明确初始化的元素依然用零值初始化

第四种方式是混合了第二种和第三种的初始化方式，前面两个元素采用顺序初始化，第三个和第四个元素采用零值初始化，第五个元素通过索引初始化，最后一个元素跟在前面的第五个元素之后采用顺序初始化

Go语言中数组是值语义。一个数组变量即表示整个数组，它并不是**隐式地指向第一个元素的指针**,例如C语言的数组

当一个数组变量被赋值或者被传递的时候，实际上会复制整个数组。如果数组较大的话，数组的赋值也会有较大的开销。为了避免复制数组带来的开销，可以传递一个指向数组的指针，但是数组指针并不是数组

```
package main

import (
	"fmt"
)

func main() {
	var a = [...]int{1, 2, 3}
	var b = &a //b是指向数组的指针
	fmt.Println(a[0], a[1])
	fmt.Println(b[0], b[1])

	for i, v := range b {
		fmt.Println(i, v)
	}
}
```

其中b是指向数组a的指针，但是通过b访问数组中元素的写法和a是类似的。还可以通过for range来迭代数组指针指向的数组元素。其实数组指针类型除类型和数组不同之外，通过数组指针操作数组的方式和通过数组本身的操作类似，而且数组指针赋值时只会复制一个指针。但是数组指针类型依然不够灵活，因为数组的长度是数组类型的组成部分，指向不同长度数组的数组指针类型也是完全不同的

遍历数组的几种方式:
```
package main

import (
	"fmt"
)

func main() {
	var a = [...]int{1, 2, 3}

	for i := range a {
		fmt.Printf("a[%d]: %d\n", i, a[i])
	}

	for i, v := range a {
		fmt.Printf("a[%d]: %d\n", i, v)
	}

	for i := 0; i < len(a); i++ {
		fmt.Printf("a[%d]: %d\n", i, a[i])
	}
}
```

用for range方式迭代的性能可能会更好一些，因为这种迭代可以保证不会出现数组越界的情形，每轮迭代对数组元素的访问时可以省去对下标越界的判断

用for range方式迭代，还可以忽略迭代时的下标:
```
var times [5][0]int
for range times {
	fmt.Println("hello")
}
```
其中times对应一个[5][0]int类型的数组，虽然第一维数组有长度，但是数组的元素[0]int大小是0，因此整个数组占用的内存大小依然是0。不用付出额外的内存代价，我们就通过for range方式实现times次快速迭代


数组不仅可以定义数值数组，还可以定义字符串数组、结构体数组、函数数组、接口数组、通道数组等

```
package main

import (
	"fmt"
	"image"
	"image/jpeg"
	"image/png"
	"io"
)

func main() {
	//字符串数组
	var s1 = [2]string{"hello", "world"}
	var s2 = [...]string{"hello", "go"}
	var s3 = [...]string{1: "hello", 0: "world"} //通过索引
	fmt.Println(s1, s2, s3)

	//结构体数组
	var line1 [2]image.Point
	var line2 = [...]image.Point{image.Point{X: 0, Y: 0}, image.Point{X: 1, Y: 1}}
	var line3 = [...]image.Point{{0, 0}, {1, 1}}
	fmt.Println(line1, line2, line3)

	//函数数组
	var decoder1 [2]func(io.Reader) (image.Image, error)
	var decoder2 = [...]func(io.Reader) (image.Image, error){
		png.Decode,
		jpeg.Decode,
	}
	fmt.Println(decoder1, decoder2)

	//接口数组
	var unknown1 [2]interface{}
	var unknown2 = [...]interface{}{123, "你好"}
	fmt.Println(unknown1, unknown2)

	//通道数组
	var chanList = [2]chan int{}
	fmt.Println(chanList)

	//空数组
	var d [0]int
	var e = [0]int{}
	var f = [...]int{}
	fmt.Println(d, e, f)
}
```

长度为0的数组（空数组）在内存中并不占用空间。空数组虽然很少直接使用，但是可以用于强调某种特有类型的操作时避免分配额外的内存空间，例如用于通道的同步操作:

```
ch1 := make(chan [0]int)
go func() {
	fmt.Println("ch1")
	ch1 <- [0]int{}
}()
<-ch1
```

在这里，我们并不关心通道中传输数据的真实类型，其中通道接收和发送操作只是用于消息的同步。对于这种场景，我们用空数组作为通道类型可以减少通道元素赋值时的开销。当然，一般更倾向于用无类型的匿名结构体代替空数组:

```
ch2 := make(chan struct{})
go func() {
	fmt.Println("ch2")
	ch2 <- struct{}{}  //struct{}部分是类型，{}部分表示对应的结构体值
}()
<-ch2
```

我们可以用fmt.Printf()函数提供的%T或%#v谓词语法来打印数组的类型和详细信息:
```
fmt.Printf("b: %T\n", b)
fmt.Printf("b: %#v\n", b)
```

在Go语言中，数组类型是切片和字符串等结构的基础


### 字符串

一个字符串是一个不可改变的字节序列，字符串通常是用来包含人类可读的文本数据

和数组不同的是，字符串的元素不可修改，是一个只读的字节数组。每个字符串的长度虽然也是固定的，但是字符串的长度并不是字符串类型的一部分

由于Go语言的源代码要求是UTF8编码，导致Go源代码中出现的字符串面值常量一般也是UTF8编码的。源代码中的文本字符串通常被解释为采用UTF8编码的Unicode码点（rune）序列

因为字节序列对应的是只读的字节序列，所以字符串可以包含任意的数据，包括字节值0

我们也可以用字符串表示GBK等非UTF8编码的数据，不过这时候将字符串看作是一个只读的二进制数组更准确，因为for range等语法并不能支持非UTF8编码的字符串的遍历

Go语言字符串的底层结构在reflect.StringHeader中定义:
```
type StringHeader struct {
	Data uintptr
	Len int
}
```

字符串结构由两个信息组成：第一个是字符串指向的底层字节数组；第二个是字符串的字节的长度。字符串其实是一个结构体，因此字符串的赋值操作也就是`reflect.StringHeader`结构体的复制过程，并不会涉及底层字节数组的复制

字符串虽然不是切片，但是支持切片操作，不同位置的切片底层访问的是同一块内存数据
```
s := "hello, world"
hello := s[:5]
world := s[7:]
s1 := "hello, world"[:5]
s2 := "hello, world"[7:]
```

字符串和数组类似，内置的len()函数返回字符串的长度

根据Go语言规范，Go语言的源文件都采用UTF8编码

下面的`hello,世界`字符串中包含了中文字符，可以通过打印转型为字节类型来查看字符底层对应的数据:
```
fmt.Printf("%#v\n", []byte("hello,世界"))
```

Go语言除了`for range`语法对UTF8字符串提供了特殊支持外，还对`字符串`和`[]rune`类型的相互转换提供了特殊的支持
```
[]rune("世界")
string([]rune{'世', '界'})
```

可以发现`[]rune`其实是`[]int32`类型，这里的`rune`只是`int32`类型的别名，并不是重新定义的类型。`rune`用于表示每个`Unicode`码点，目前只使用了21个位

字符串相关的强制类型转换主要涉及`[]byte`和`[]rune`两种类型。每个转换都可能隐含重新分配内存的代价，最坏的情况下它们运算的时间复杂度都是`O(n)`。不过字符串和`[]rune`的转换要更为特殊一些，因为一般这种强制类型转换要求两个类型的底层内存结构要尽量一致，显然它们底层对应的`[]byte`和`[]int32`类型是完全不同的内存结构，因此这种转换可能隐含重新分配内存的操作


### 切片
切片（slice）就是一种简化版的动态数组

因为动态数组的长度不固定，所以切片的长度自然也就不能是类型的组成部分了

数组虽然有适用的地方，但是数组的类型和操作都不够灵活，因此在Go代码中数组使用得并不多。而切片则使用得相当广泛，理解切片的原理和用法是Go程序员的必备技能

切片定义方式:
```
var (
	a []int    //nil切片,和nil相等,一般用来表示一个不存在的切片
	b = []int{}  //空切片,和nil不想等,一般用来表示一个空的集合
	c = []int{1, 2, 3}  //有3个元素的切片,len和cap都为3
	d = c[:2]  //有2个元素的切片,len为2,cap为3
	e = c[0:2:cap(c)]  //有2个元素的切片,len为2,cap为3
	f = c[:0]  //有0个元素的切片,len为0,cap为3
	g = make([]int, 3)  //有3个元素的切片,len为3,cap为3
	h = make([]int, 2, 3)  //有2个元素的切片,len为2,cap为3
	i = make([]int, 0, 3)  //有0个元素的切片,len为0,cap为3
)
```

和数组一样，内置的len()函数返回切片中有效元素的长度，内置的cap()函数返回切片容量大小，容量必须大于或等于切片的长度

切片可以和nil进行比较，只有当切片底层数据指针为空时切片本身才为nil,这时候切片的长度和容量信息将是无效的。如果有切片的底层数据指针为空，但是长度和容量不为0的情况，那么说明切片本身已经被损坏了

遍历切片的方式:
```
for i := range a {
	fmt.Println(i, a[i])
}

for i, v := range b {
	fmt.Println(i, v)
}

for i := 0; i < len(c); i++ {
	fmt.Println(i, c[i])
}
```

其实除了遍历之外，只要是切片的底层数据指针、长度和容量没有发生变化，对切片的遍历、元素的读取和修改就和数组一样。在对切片本身进行赋值或参数传递时，和数组指针的操作方式类似，但是只复制切片头信息`reflect.SliceHeader`，而不会复制底层的数据。对于类型，和数组的最大不同是，切片的类型和长度信息无关，只要是相同类型元素构成的切片均对应相同的切片类型

**添加切片元素**

内置的泛型函数`append()`可以在切片的尾部追加N个元素:
```
var a []int
a = append(a, 1)     //追加一个元素
a = append(a, 1, 2, 3)  //追加多个元素
a = append(a, []int{1, 2, 3}...)  //追加一个切片
```

不过要注意的是，在容量不足的情况下，append ()操作会导致重新分配内存，可能导致巨大的内存分配和复制数据的代价。即使容量足够，依然需要用append()函数的返回值来更新切片本身，因为新切片的长度已经发生了变化

除了在切片的尾部追加，还可以在切片的开头添加元素:
```
package main

import "fmt"

func main() {
	var a = []int{1, 2, 3}
	a = append([]int{0}, a...)          //在开头添加一个元素
	a = append([]int{-3, -2, -1}, a...) //在开头添加一个切片
	fmt.Println(a)
}
```

在开头一般都会导致内存的重新分配，而且会导致已有的元素全部复制一次。因此，从切片的开头添加元素的性能一般要比从尾部追加元素的性能差很多

由于append()函数返回新的切片，也就是它支持链式操作，因此我们可以将多个append ()操作组合起来，实现在切片中间插入元素:
```
package main

import "fmt"

func main() {
	var a = []int{1, 2, 3, 4}
	a = append(a[:2], append([]int{9}, a[2:]...)...)       //在第2个位置插入9
	a = append(a[:2], append([]int{1, 2, 3}, a[2:]...)...) //在第二个位置插入切片
	fmt.Println(a)
}
```

每个添加操作中的第二个`append()`调用都会创建一个临时切片，并将`a[i:]`的内容复制到新创建的切片中，然后将临时创建的切片再追加到`a[:i]`:
```
var a []int
a = append(a[:i], append([]int{x}, a[i:]...)...)
```

copy()和append()组合可以避免创建中间的临时切片，同样是完成添加元素的操作:
```
a = append(a, 0)    //切片扩容一个空间
copy(a[i+1:], a[i:])  //a[i:]向后移动一个位置
a[i] = x  //设置新添加的元素
```

第一句中的append()用于扩展切片的长度，为要插入的元素留出空间。第二句中的copy()操作将要插入位置开始之后的元素向后挪动一个位置。第三句真实地将新添加的元素赋值到对应的位置。操作语句虽然冗长了一点，但是相比前面的方法，可以减少中间创建的临时切片

用copy()和append()组合也可以实现在中间位置插入多个元素,也就是插入一个切片:
```
a = append(a, x...)      //为x切片扩展足够的空间
copy(a[i+len(x):], a[i:])  //a[i:]向后移动len(x)个位置
copy(a[i:], x)  //复制新添加的切片
```

**删除切片元素**

根据要删除元素的位置，有从开头位置删除、从中间位置删除和从尾部删除3种情况，其中删除切片尾部的元素最快:
```
a = []int{1, 2, 3}
a = a[:len(a)-1]  //删除尾部1个元素
a = a[:len(a)-N]  //删除尾部N个元素
```

删除开头的元素可以直接移动数据指针:
```
a = []int{1, 2, 3}
a = a[1:]   //删除开头1个元素
a = a[N:]   //删除开头N个元素
```

删除开头的元素也可以不移动数据指针，而将后面的数据向开头移动。可以用`append()`原地完成,`所谓原地完成是指在原有的切片数据对应的内存区间内完成，不会导致内存空间结构的变化`:
```
a = append(1, 2, 3)
a = append(a[:0], a[1:]...)  //删除开头1个元素
a = append(a[:0], a[N:]..)   //删除开头N个元素
```

也可以用copy()完成删除开头的元素:
```
a = []int{1, 2, 3}
a = a[:copy(a, a[1:])]  //删除开头一个元素
a = a[:copy(a, a[N:])]  //删除开头N个元素
```

对于删除中间的元素，需要对剩余的元素进行一次整体挪动，同样可以用`append()`或`copy()`原地完成:
```
a := []int{1, 2, 3, ...}
a = append(a[:i], a[i+1:]...)  //删除中间1个元素
a = append(a[:i], a[i+N:]...)  //删除中间N个元素
a = a[:i+copy(a[i:], a[i+1:])]  //删除中间1个元素
a = a[:i+copy(a[i:], a[i+N:])]  //删除中间N个元素
```

**切片内存技巧**

对于切片来说，len为0但是cap容量不为0的切片则是非常有用的特性。当然，如果len和cap都为0的话，则变成一个真正的空切片，虽然它并不是一个nil的切片。在判断一个切片是否为空时，一般通过len获取切片的长度来判断，一般很少将切片和nil做直接的比较