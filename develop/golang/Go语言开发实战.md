#### 变量的概念
- 变量是计算机语言中储存数据的基本单元。变量的功能是存储数据
- 变量的本质是计算机分配的一小块内存，专门用于存放指定数据，在程序运行过程中该数值可以发生改变；变量的存储往往具有瞬时性，或者说是临时存储，当程序运行结束，存放该数据的内存就会释放，该变量就会随着内存的释放而消失

#### 全局变量与局部变量
- 局部变量，是定义在大括号`（{}）`内部的变量，大括号的内部也是局部变量的作用域。
- 全局变量，是定义在函数和大括号`（{}）`外部的变量。

#### 变量声明
```
var a int

var (
    a int
    b string
    c bool
    d []float32
    e func() bool
    f struct {
        x int
        y string
    }
)
```

**未初始化变量的默认值有如下特点。**
- 整型和浮点型变量默认值：0。
- 字符串默认值为空字符串。
- 布尔型默认值为false。
- 函数、指针变量、切片默认值为nil。

**初始化变量**
```
var a int = 3
var b = 4
c := 5
```

使用 `:=` 赋值操作符可以高效地创建一个新的变量，称为初始化声明。声明语句省略了 `var` 关键字，变量类型将由编译器自动推断。这是声明变量的首选形式，但是它只能被用在`函数体内`，而不可以用于全局变量的声明与赋值。

#### 变量多重赋值
变量多重赋值是指多个变量同时赋值。Go语法中，变量初始化和变量赋值是两个不同的概念。Go语言的变量赋值与其他语言一样，但是Go提供了其他程序员期待已久的多重赋值功能，可以实现变量交换。多重赋值让Go语言比其他语言减少了代码量。

```
    var a int = 10
	var b int = 20
	var tmp int
	tmp = a
	a = b
	b = tmp

    ---------------------

    var a int = 10
    var b int = 20
    b, a = a, b
```

#### 匿名变量
Go语言的函数可以返回多个值，而事实上并不是所有的返回值都用得上。那么就可以使用匿名变量，用下画线`_`替换即可。

```
package main

import "fmt"

func main() {
	a, _ := test() //舍弃第二个值
	_, b := test() //舍弃第一个值
	fmt.Println(a, b)
}

func test() (int, int) {
	return 1, 2
}
```

**匿名变量既不占用命名空间，也不会分配内存**

#### 数据类型
在计算机中，操作的对象是数据，那么大家来思考一下，如何选择合适的容器来存放数据才不至于浪费空间？

在Go语言中，有以下几种数据类型：
- 基本数据类型：整型、浮点型、复数型、布尔型、字符串、字符（byte、rune）
- 复合数据类型：数组（array）、切片（slice）、映射（map）、函数（function）、结构体（struct）、通道（channel）、接口（interface）、指针（pointer）

#### 整形
- 有符号整型：int8、int16、int32、int64、int
- 无符号整型：uint8、uint16、uint32、uint64、uint

**其中uint8就是byte型**

#### 浮点型
浮点型表示存储的数据是实数，如3.475

- float32, 4个字节，32位的浮点型
- float64, 8个字节，64位的浮点型

```
var x float32
var y float64
```

#### 复数型
复数型用于表示数学中的复数，如`1+2j、1-2j、-1-2j`等

- complex64, 8个字节，64位的复数型
- complex128, 16个字节，128位的复数型

#### 布尔型
布尔型用预定义标识符bool表示，
布尔型的值只可以是常量true或者false

```
var flag bool
```
**布尔型无法参与数值运算，也无法与其他类型进行转换**


#### 字符串
字符串在Go语言中是以基本数据类型出现的

**定义多行字符串的方法如下：**
- 双引号书写字符串被称为字符串字面量，这种字面量不能跨行
- 多行字符串需要使用反引号 ` ，多用于内嵌源码和内嵌数据
- 在反引号中的所有代码不会被编译器识别，而只是作为字符串的一部分

```
package main

import "fmt"

func main() {
	var temp string
	temp = `
		x := 10
		y := 20
		fmt.Println(x, y)
	`
	fmt.Println(temp)
}

```

#### 字符
字符串中的每一个元素叫作字”，定义字符时使用`单引号`。Go语言的字符有两种

- byte , 1个字节，uint8的别名类型，表示 utf-8 字符串的单个字节的值
- rune , 4个字节，int32的别名类型，表示单个 unicode 字符

```
var a byte = 'a'
var b rune = '我'
```

#### 打印格式化
打印格式化通常使用fmt包

- %v, 值的默认格式表示
- %+v, 类似%v，但输出结构体时会打印字段名
- %#v，值的Go语法表示
- %T，值的类型Go语法表示

```
package main

import "fmt"

func main() {
	str := "hello, world"
	fmt.Printf("%T, %v \n", str, str)
	var a rune = '帅'
	fmt.Printf("%T, %v \n", a, a)
}
```

#### 布尔型打印格式

%t, 打印内容为 `true` 或 `false`

```
package main

import "fmt"

func main() {
	var flag bool
	fmt.Printf("%T, %t \n", flag, flag)
	flag = true
	fmt.Printf("%T, %t \n", flag, flag)
}
```

#### 整形打印格式

- %b, 表示二进制
- %d, 表示十进制
- %x, 表示十六进制

#### 浮点型与复数型的打印格式

- %b
- %e
- %E
- %f
- %F
- %g
- %G


#### 字符串打印格式

- %s, 直接输出字符串
- %q


#### 数据类型转换

Go语言采用数据类型前置加括号的方式进行类型转换，格式如：T（表达式）。T表示要转换的类型；表达式包括变量、数值、函数返回值等

**类型转换时，需要考虑两种类型之间的关系和范围，是否会发生数值截断**

**布尔型无法与其他类型进行转换**

```
var a int = 10
b := float64(a)  //将 int型转换成 float64 型
c := string(a)   //将 int型转换成 string 型
```

float和int的类型精度不同，使用时需要注意float转int时精度的损失

#### 整形转字符串类型
这种类型的转换，其实相当于byte或rune转string。

**在Go语言中，不允许字符串转int**


#### 常量
相对于变量，常量是恒定不变的值，如圆周率。常量是一个简单值的标识符，在程序运行时，不会被修改。常量中的数据类型只可以是布尔型、数字型（整型、浮点型和复数型）和字符串。

```
const A int = 5
Const S string = "TEST"
```
可以省略类型说明符，因为编译器可以根据变量的值来自动推断其类型
```
const A = 3
```

常量组中如果不指定类型和初始值，则与上一行非空常量的值相同
```
package main

import "fmt"

const (
	a = 10
	b
	c
)

func main() {

	fmt.Println(a, b, c)
}
```
输出结构都为 10


#### iota
iota，特殊常量值，是一个系统定义的可以被编译器修改的常量值。iota只能被用在常量的赋值中，在每一个const关键字出现时，被重置为0，然后每出现一个常量，iota所代表的数值会自动增加1。iota可以理解成常量组中常量的计数器，不论该常量的值是什么，只要有一个常量，那么iota就加1

```
package main

import "fmt"

const (
	a = iota
	b = iota
	c = iota
)

func main() {
	fmt.Println(a, b, c)
}
```
输出结果为 0 1 2


#### 类型别名
说到类型别名，无非是给类型名取一个有特殊含义的外号而已，对于编程而言，类型别名主要用于解决兼容性的问题。

`type AliasStr = string` 将 AliasStr 定义为 string 的一个别名，使用 AliasStr 与 string 等效。


#### 运算符
- ，+ , - , * , / , %
- ++ , --
- == , != , > , < , >= , <=
- && , || , !
- = , += , -= , *= , /= ,


#### 位运算符
位运算符对整数在内存中的二进制位进行操作。

位运算符比一般的算术运算符速度要快，而且可以实现一些算术运算符不能实现的功能。如果要开发高效率程序，位运算符是必不可少的。位运算符用来对二进制位进行操作，包括：按位与（＆）、按位或（|）、按位异或（^）、按位左移（＜＜）、按位右移（＞＞）

- &    对应的二进制位相与
- |
- ^    异或，相同为0，不同为1
- <<   左移运算符，左移n位就是乘以2的n次方
- .>>


取址运算符：&
指针变量：*

**注意运算符的优先级**

### 流程控制
- if
- if ... else..
- switch
- select
- for
- break
- continue
- goto
- 循环嵌套

**if变体**
```
package main

import "fmt"

func main() {
	if num := 10; num%2 == 0 {
		fmt.Println(num)
	} else {
		fmt.Println(num)
	}
}
```

### 函数与指针

Go 语言从设计上对函数进行了优化和改进，让函数使用起来更加方便。因为Go语言的函数本身可以作为值进行传递，既支持匿名函数和闭包，又能满足接口

### 函数作为值
在Go语言中，函数也是一种类型，可以和其他类型，如int32、float等等，一样被保存在变量中

函数作为值的使用步骤：
-  定义一个函数类型
-  实现定义的函数类型
-  作为参数调用

### 匿名函数
Go语言支持匿名函数，即在需要使用函数时再定义函数。匿名函数没有**函数名**，只有函数体，函数可以作为一种类型被赋值给变量，匿名函数也往往以变量方式被传递

匿名函数经常被用于实现回调函数、闭包等
```
//语法格式

func(a, b int) (x, y int) {
		return a, b
	}
```

### 在定义时调用匿名函数
```
package main

import "fmt"

func main() {
	func(data int) {
		fmt.Println("hello, ", data)
	}(12345)
}

```

### 将匿名函数赋值给变量
```
package main

import "fmt"

func main() {
	f := func(data string) {
		fmt.Println(data)
	}
	f("Hello Go !")
}

```

### 匿名函数作为回调函数
```
package main

import (
	"fmt"
	"math"
)

func main() {
	arr := []float64{1, 9, 16, 25, 30}
	visit(arr, func(v float64) {
		v = math.Sqrt(v)
		fmt.Printf("%.2f \n", v)
	})

	visit(arr, func(v float64) {
		v = math.Pow(v, 2)
		fmt.Printf("%.0f \n", v)
	})
}

func visit(list []float64, f func(float64)) {
	for _, value := range list {
		f(value)
	}
}
```

### 闭包
闭包是由函数和与其相关的引用环境组合而成的实体。在实现深约束时，需要创建一个能显式表示引用环境的东西，并将它与相关的子程序捆绑在一起，这样捆绑起来的整体被称为闭包。函数 + 引用环境 = 闭包

闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例

闭包有益于模块化编程，便于以简单的方式开发较小的模块，从而提高开发速度和程序的可复用性。和没有使用闭包的程序相比，使用闭包可将模块划分得更小。比如要计算一个数组中所有数字的和，只需要循环遍历数组，把遍历到的数字加起来就行了。如果现在要计算所有元素的积，又或者要打印所有的元素呢？解决这些问题都要对数组进行遍历，如果是在不支持闭包的语言中，程序员不得不一次又一次重复地写循环语句。而这在支持闭包的语言中是不必要的。这种处理方法多少有点像回调函数，不过要比回调函数写法更简单，功能更强大。

没有使用闭包进行计数的代码：
```
package main

import (
	"fmt"
)

func main() {
	for i := 0; i < 5; i++ {
		fmt.Printf("i=%d \t", i)
		fmt.Println(add(i))
	}
}

func add(x int) int {
	sum := 0
	sum += x
	return sum
}
```

使用闭包函数实现计数器：
```
package main

import (
	"fmt"
)

func main() {
	pos := add()
	for i := 0; i < 10; i++ {
		fmt.Printf("i=%d \t", i)
		fmt.Println(pos(i))
	}
	fmt.Println("------------")
	for i := 0; i < 10; i++ {
		fmt.Printf("i=%d \n", i)
		fmt.Println(pos(i))
	}
}

func add() func(int) int {
	sum := 0
	return func(x int) int {
		fmt.Printf("sum1=%d \t", sum)
		sum += x
		fmt.Printf("sum2=%d \t", sum)
		return sum
	}
}
```

### 可变参数
如果一个函数的参数，类型一致，但个数不定，可以使用函数的可变参数

当要传递若干个值到可变参数函数中时，可以手动书写每个参数，也可以将一个slice传递给该函数，通过“...”可以将slice中的参数对应地传递给函数

```
package main

import (
	"fmt"
)

func main() {
	sum, avg, count := GetScore(90, 82.5, 73, 93.6)
	fmt.Printf("%d-%.2f-%.2f", count, sum, avg)
	fmt.Println()

	scores := []float64{92, 65.45, 78, 98.5, 89}
	sum, avg, count = GetScore(scores...)
	fmt.Printf("%d-%.2f-%.2f", count, sum, avg)
}

func GetScore(scores ...float64) (sum, avg float64, count int) {
	for _, value := range scores {
		sum += value
		count++
	}
	avg = sum / float64(count)
	return
}
```

 - 一个函数最多只能有一个可变参数
 - 若参数列表中还有其他类型参数，则可变参数写在所有参数的最后


### 递归函数
在函数内部，可以调用其他函数。如果一个函数在内部调用自身，那么这个函数就是递归函数。递归函数必须满足以下两个条件：
1. 在每一次调用自己时，必须是在某种意义上更接近于解。
2. 必须有一个终止处理或计算的准则。

使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层，每当函数返回，栈就会减一层。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。

- 使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出


## 指针
指针是存储另一个变量的内存地址的变量。变量是一种使用方便的占位符，变量都指向计算机的内存地址。一个指针变量可以指向任何一个值的内存地址

在Go语言中使用取地址符 `＆` 来获取变量的地址，一个变量前使用 `＆` ，会返回该变量的内存地址

```
package main

import (
	"fmt"
)

func main() {
	a := 10
	b := &a
	fmt.Println(a, b)
}
```

**Go语言指针的最大特点是：指针不能运算（不同于C语言）**

### 声明指针
`*`号用于指定变量是一个指针
```
var a *int
var b *float32
```

指针使用流程如下:
- 定义指针变量
- 为指针变量赋值
- 访问指针变量中指向地址的值
  
获取指针指向的变量值,在指针类型的变量前加上 `*` 号，如 `*a`

```
package main

import (
	"fmt"
)

func main() {
	a := 10
	b := &a
	fmt.Println(a)
	fmt.Println(b)
	fmt.Println(*b)
}
```

### 空指针
在Go语言中，当一个指针被定义后没有分配到任何变量时，它的值为nil。nil指针也称为空指针。nil在概念上和其他语言的null、None、NULL一样，都指代零值或空值

### 通过指针修改变量的值
```
func main() {
	a := 10
	fmt.Println(a)
	b := &a
	*b++
	fmt.Println(a)
}
```

### 使用指针作为函数的参数
```
package main

import (
	"fmt"
)

func main() {
	a := 5
	var b *int = &a
	change(b)
	fmt.Println(a)
}

func change(val *int) {
	*val = 15
}
```

**将基本数据类型的指针作为函数的参数，可以实现对传入数据的修改，这是因为指针作为函数的参数只是复制了一个指针，指针指向的内存没有发生改变**


### 指针数组
元素为指针类型的数组

有一个元素个数与之相同的数组，将该数组中每个元素的地址赋值给该指针数组。也就是说该指针数组与某一个数组完全对应。可以通过 `*` 指针变量获取到该地址所对应的数值

```
package main

import "fmt"

func main() {
	a := [4]string{"abc", "xyz", "lss", "go"}
	var ptr [4]*string

	for i := 0; i < 4; i++ {
		ptr[i] = &a[i]
	}

	for _, v := range ptr {
		fmt.Println(v)
		fmt.Println()
		fmt.Println(*v)
	}
}
```

### 指针的指针
如果一个指针变量存放的又是另一个指针变量的地址，则称这个指针变量为指向指针的指针变量。当定义一个指向指针的指针变量时，第一个指针存放第二个指针的地址，第二个指针存放变量的地址

访问指向指针的指针变量值需要使用两个 `*` 号

```
package main

import "fmt"

func main() {
	var a int = 30
	var ptr *int
	var pptr **int

	ptr = &a
	pptr = &ptr

	fmt.Println(a)
	fmt.Println(ptr)
	fmt.Println(pptr)
}
```

## 函数的参数传递
- 值传递
- 引用传递

### 值传递
值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到原内容数据

默认情况下，Go语言使用的是值传递，即在调用过程中不会影响到原内容数据。每次调用函数，都将实参复制一份再传递到函数中

每次都复制一份，性能会下降，但是Go 语言中使用指针和值传递配合就避免了性能降低问题，也就是通过传指针参数来解决实参复制的问题

### 引用传递
引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到原内容数据

严格来说Go语言只有值传递这一种传参方式，Go语言是没有引用传递的

Go语言中可以借助传指针来实现引用传递的效果。函数参数使用指针参数，传参的时候其实是复制一份指针参数，也就是复制了一份变量地址。函数的参数如果是指针，当函数调用时，虽然参数仍然是按复制传递的，但是此时仅仅只是复制一个指针，也就是一个内存地址，这样就不用担心实参复制造成的内存浪费、时间开销、性能降低

- 指针使得多个函数能操作同一个对象
- 传指针更轻量级（8 bytes），只需要传内存地址
- 如果参数是非指针参数，那么值传递的过程中，每次在复制上面就会花费相对较多的系统开销（内存和时间）。所以要传递大的结构体的时候，用指针是一个明智的选择
- Go语言中slice、map、chan类型的实现机制都类似指针，所以可以直接传递，而不必取地址后传递指针


Go语言中所有的传参都是值传递（传值），都是一个副本。副本的内容有的是值类型（int、string、bool、array、struct属于值类型），这样在函数中就无法修改原内容数据；有的是引用类型（pointer、 slice、map、chan属于引用类型），这样就可以修改原内容数据


## Go 数组
数组是相同类型的一组数据构成的长度固定的序列，其中数据类型包含了基本数据类型、复合数据类型和自定义类型

因为数组的内存是一段连续的存储区域，所以数组的检索速度是非常快的，但是数组也有一定的缺陷，就是定义后长度不能更改

Go语言数组声明需要指定元素类型及元素个数

```
var a = [5]int{1, 2, 3, 4, 5}
var b = [...]{3, 5, 7}
```

数组长度：`len(a)`

### 遍历数组
```
//one
for i := 0; i < len(a); i++ {
    fmt.Println(a[i])
}

//two
for _, v := range a {
    fmt.Println(a)
}
```

### 多维数组

Go语言中的数组并非引用类型，而是值类型。当它们被分配给一个新变量时，会将原始数组复制出一份分配给新变量。因此对新变量进行更改，原始数组不会有反应

```
package main

import "fmt"

func main() {
	var a = [3][4]int{
		{1, 2, 3, 4},
		{10, 20, 30, 40},
		{100, 200, 300, 400},
	}
	fmt.Println(a)
}


var str [2][3]string = [2][3]string{
    {"", "", ""},
    {"", "", ""},
}
```

## Go 切片

Go语言中数组的长度不可改变，但在很多应用场景中，在初始定义数组时，数组的长度并不可预知，这样的序列集合无法满足要求

Go中提供了另外一种内置类型“切片（slice）”，弥补了数组的缺陷。切片是可变长度的序列，序列中每个元素都是相同的类型

切片的语法和数组很像。从底层来看，切片引用了数组的对象。切片可以追加元素，在追加时可能使切片的容量增大

与数组相比，切片不需要设定长度，在[]中不用设定值，相对来说比较自由

切片的数据结构可理解为一个结构体，这个结构体包含了三个元素:
- 指针，指向数组中切片指定的开始位置
- 长度，即切片的长度
- 容量，也就是切片开始位置到数组的最后位置的长度


