# 数据结构--算法（理论）

## 如何学习和训练算法与数据结构
`其实只要你持之以恒，你所想的每一种方法都可以助你成功学好`

`不要迷恋技巧，也不要迷恋热血沸腾的宣传，迷恋自己的自信就好，自信与自负自己把握好就好`

## 时间复杂度 & 空间复杂度
### 空间复杂度
空间复杂度表示算法的存储空间与数据规模之间的增长关系。

也可以理解为该算法所耗费的存储空间

但空间复杂度不是用来计算程序实际占用的空间的，而是对一个算法在运行过程中临时占用存储空间大小的一个度量，反映的是一个趋势

空间复杂度我们用 `S(n)` 来定义

常见的空间复杂度有 `O(1)`, `O(n)`, `O(n^2)`，像 `O(logn)`, `O(nlogn)` 很少用到

**空间复杂度 O(1)**

如果算法执行所需要的临时空间不随着某个变量 n 的大小而变化，即该算法的空间复杂度为一个常量，则空间该算法的空间复杂度可表示为 O(1)
```
func main() {
    i, j := 1, 2
    i++
    j++
    x := i + j
    fmt.Println(x)
}

代码中的变量 i , j , x 所分配的空间不会随着数据规模的增大而变化，所以 S(n) = O(1)
```

**空间复杂度 O(n)**
```
func main() {
    arr := [n]int
    for i := 1; i <= n; i++ {
        j := i
        j++
    }
}

数组 arr 占用的空间大小为 n，代码中有循环，但是不会在分配新的空间，
所以该算法的空间复杂度主要看 arr := [n]int ,即 S(n) = O(n)
```

### 时间复杂度
数据结构和算法本身解决的是 快 和 省 的问题，即如何让代码运行的更快，如何让代码更省存储空间。

#### 大 O 复杂度表示法
`T(n) = O(f(n))`

T(n) 表示代码的执行时间，n 表示数据规模的大小，f(n) 表示每行代码执行的次数总和。

公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。

```
T(n) = O(2n + 2)
T(n) = O(2n^2 + 2n + 3)

类似上面两种表示 就是 大O时间复杂度表示法
```
大 O 时间复杂度实际上并不具体表示代码的实际执行时间，而是表示 代码执行时间随着数据规模增长的变化趋势，简称 时间复杂度。

当 n 很大时，公式中的低阶，常量，系数 并不左右增长趋势，所以都可以忽略。

#### 时间复杂度分析
* 只关注循环次数最多的一段代码
  
  大 O 复杂度方法表示的是一种变化趋势，我们通常会忽略掉公式中的常量，低阶，系数，只需要记录一个最大阶的量级就可以了。
  
  因此，我们在分析一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了。
  
  ```
  func main() {
      sum := 0
      i := 1
      for ; i <= n; i++ {
          sum := sum + i
      }
      fmt.Println(sum)
  }

  其中 sum := 0 , i := 1 是常量级的执行时间，与 n 无关，故对复杂度没有影响。执行次数最多的是循环体内的代码，被执行了 n 次，所以总的时间复杂度就是 O(n)。
  ```

* 加法原则，总复杂度等于量级最大的那段代码的复杂度
  
  ```
  func test(n int) int {
      sum_1 := 0
      p := 1
      for ; p < 100; p++ {
          sum_1 = sum_1 + p
      }

      sum_2 := 0
      q := 1
      for ; q < n; q++ {
          sum_2 = sum_2 + q
      }

      sum_3 := 0
      i, j := 1, 1
      for ; i <= n; i++ {
          j = 1
          for ; j <= n; j++ {
              sum_3 = sum_3 + i * j
          }
      }

      return sum_1 + sum_2 + sum_3
  }

  该代码是分别去求 sum_1, sum_2, sum_3,
  
  其中sum_1 循环了 100 次，是一个常量的执行时间，跟 n 的规模无关，
  
  sum_2 的时间复杂度是 O(n), 
  
  sum_3 的时间复杂度是 O(n^2)。

  通过分析，我们取最大的量级，所以，代码的整体时间复杂度为 O(n^2)。
  ```

  即 总的时间复杂度就等于量级最大的那段代码的时间复杂度。
  ```
  T1(n) = O(f(n))
  T2(n) = O(g(n))

  T(n) = T1(n) + T2(n) = max(O(f(n)), O(g(n))) = O(max(f(n), g(n)))
  ```

* 乘法原则，嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
  ```
  T1(n) = O(f(n))
  T2(n) = O(g(n))

  T(n) = T1(n)*T2(2) = O(f(n))*O(g(n)) = O(f(n)*g(n))

  即 T1(n) = O(n), T2(n) = O(n^2), 则 T1(n)*T2(n) = O(n^3)
  ```
  示例代码：
  ```
  func test(n int) {
      ret := 0
      i := 1
      for ; i < n; i++ {
          ret = ret + f(i)
      }
  }

  func f(n int) int {
      sum := 0
      i := 1
      for ; i < n; i++ {
          sum = sum + i
      }
      return sum
  }

  如果 f() 只是一个普通的操作，那么 test() 的复杂度就是 O(n)，
  
  但由于 f() 的时间复杂度是 O(n)，所以整个 test() 函数的时间复杂度是：

  T(n) = T1(n)*T2(n) = O(n*n) = O(n^2)
  ```

#### 常见时间复杂度实例分析

* 复杂度量级
  ```
  常量阶      O(1)
  对数阶      O(logn)
  线性阶      O(n)
  线性对数阶  O(nlogn)
  平方阶      O(n^2)
  立方阶      O(n^3)
  k次方阶     O(n^k)
  指数阶      O(2^n)
  阶乘阶      O(n!)
  ```

* O(1)
  
  O(1) 只是常数级时间复杂度的一种表示，不是指只执行一行代码。
  ```
  i, j := 8, 6
  sum := i + j
  ```
  只要代码的执行时间不随 n 的增大而增加，这样的代码时间复杂度我们都记为 O(1).

  一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上行的代码，其时间复杂度也是 O(1)。

* O(logn), O(nlogn)

