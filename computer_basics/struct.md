# 数据结构--算法（理论）

## 如何学习和训练算法与数据结构
`其实只要你持之以恒，你所想的每一种方法都可以助你成功学好`

`不要迷恋技巧，也不要迷恋热血沸腾的宣传，迷恋自己的自信就好，自信与自负自己把握好就好`

## 时间复杂度 & 空间复杂度
### 空间复杂度
空间复杂度表示算法的存储空间与数据规模之间的增长关系。

也可以理解为该算法所耗费的存储空间

但空间复杂度不是用来计算程序实际占用的空间的，而是对一个算法在运行过程中临时占用存储空间大小的一个度量，反映的是一个趋势

空间复杂度我们用 `S(n)` 来定义

常见的空间复杂度有 `O(1)`, `O(n)`, `O(n^2)`，像 `O(logn)`, `O(nlogn)` 很少用到

**空间复杂度 O(1)**

如果算法执行所需要的临时空间不随着某个变量 n 的大小而变化，即该算法的空间复杂度为一个常量，则空间该算法的空间复杂度可表示为 O(1)
```
func main() {
    i, j := 1, 2
    i++
    j++
    x := i + j
    fmt.Println(x)
}

代码中的变量 i , j , x 所分配的空间不会随着数据规模的增大而变化，所以 S(n) = O(1)
```

**空间复杂度 O(n)**
```
func main() {
    arr := [n]int
    for i := 1; i <= n; i++ {
        j := i
        j++
    }
}

数组 arr 占用的空间大小为 n，代码中有循环，但是不会在分配新的空间，
所以该算法的空间复杂度主要看 arr := [n]int ,即 S(n) = O(n)
```

### 时间复杂度
数据结构和算法本身解决的是 快 和 省 的问题，即如何让代码运行的更快，如何让代码更省存储空间。

#### 大 O 复杂度表示法
`T(n) = O(f(n))`

T(n) 表示代码的执行时间，n 表示数据规模的大小，f(n) 表示每行代码执行的次数总和。

公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。

```
T(n) = O(2n + 2)
T(n) = O(2n^2 + 2n + 3)

类似上面两种表示 就是 大O时间复杂度表示法
```
大 O 时间复杂度实际上并不具体表示代码的实际执行时间，而是表示 代码执行时间随着数据规模增长的变化趋势，简称 时间复杂度。

当 n 很大时，公式中的低阶，常量，系数 并不左右增长趋势，所以都可以忽略。

#### 时间复杂度分析
* 只关注循环次数最多的一段代码
  
  大 O 复杂度方法表示的是一种变化趋势，我们通常会忽略掉公式中的常量，低阶，系数，只需要记录一个最大阶的量级就可以了。
  
  因此，我们在分析一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了。
  
  ```
  func main() {
      sum := 0
      i := 1
      for ; i <= n; i++ {
          sum := sum + i
      }
      fmt.Println(sum)
  }

  其中 sum := 0 , i := 1 是常量级的执行时间，与 n 无关，故对复杂度没有影响。
  
  执行次数最多的是循环体内的代码，被执行了 n 次，所以总的时间复杂度就是 O(n)。
  ```

* 加法原则，总复杂度等于量级最大的那段代码的复杂度
  
  ```
  func test(n int) int {
      sum_1 := 0
      p := 1
      for ; p < 100; p++ {
          sum_1 = sum_1 + p
      }

      sum_2 := 0
      q := 1
      for ; q < n; q++ {
          sum_2 = sum_2 + q
      }

      sum_3 := 0
      i, j := 1, 1
      for ; i <= n; i++ {
          j = 1
          for ; j <= n; j++ {
              sum_3 = sum_3 + i * j
          }
      }

      return sum_1 + sum_2 + sum_3
  }

  该代码是分别去求 sum_1, sum_2, sum_3,
  
  其中sum_1 循环了 100 次，是一个常量的执行时间，跟 n 的规模无关，
  
  sum_2 的时间复杂度是 O(n), 
  
  sum_3 的时间复杂度是 O(n^2)。

  通过分析，我们取最大的量级，所以，代码的整体时间复杂度为 O(n^2)。
  ```

  即 总的时间复杂度就等于量级最大的那段代码的时间复杂度。
  ```
  T1(n) = O(f(n))
  T2(n) = O(g(n))

  T(n) = T1(n) + T2(n) = max(O(f(n)), O(g(n))) = O(max(f(n), g(n)))
  ```

* 乘法原则，嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
  ```
  T1(n) = O(f(n))
  T2(n) = O(g(n))

  T(n) = T1(n)*T2(2) = O(f(n))*O(g(n)) = O(f(n)*g(n))

  即 T1(n) = O(n), T2(n) = O(n^2), 则 T1(n)*T2(n) = O(n^3)
  ```
  示例代码：
  ```
  func test(n int) {
      ret := 0
      i := 1
      for ; i < n; i++ {
          ret = ret + f(i)
      }
  }

  func f(n int) int {
      sum := 0
      i := 1
      for ; i < n; i++ {
          sum = sum + i
      }
      return sum
  }

  如果 f() 只是一个普通的操作，那么 test() 的复杂度就是 O(n)，
  
  但由于 f() 的时间复杂度是 O(n)，所以整个 test() 函数的时间复杂度是：

  T(n) = T1(n)*T2(n) = O(n*n) = O(n^2)
  ```

#### 常见时间复杂度实例分析

* 复杂度量级
  ```
  常量阶      O(1)
  对数阶      O(logn)
  线性阶      O(n)
  线性对数阶  O(nlogn)
  平方阶      O(n^2)
  立方阶      O(n^3)
  k次方阶     O(n^k)
  指数阶      O(2^n)
  阶乘阶      O(n!)
  ```

* O(1)
  
  O(1) 只是常数级时间复杂度的一种表示，不是指只执行一行代码。
  ```
  i, j := 8, 6
  sum := i + j
  ```
  只要代码的执行时间不随 n 的增大而增加，这样的代码时间复杂度我们都记为 O(1).

  一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上行的代码，其时间复杂度也是 O(1)。

* O(logn), O(nlogn)

  ```
  i := 1
  for i < n {
      i = i * 2
  }

  变量 i 的值 从 1 开始取，每循环一次就乘以2

  变量 i 的取值类似于一个等比数列

  2^0, 2^1, 2^2 ... 2^x = n

  我们只要知道 x 的值是多少，就知道这行代码的执行次数了

  即 2^x = n 得出 x = log2^n

  故该代码的时间复杂度为 O(log2^n)
  ```

  不管以2 为底 还是 以3 为底，我们把所有对数阶的时间复杂度都记为 O(logn).

  如果一段代码的时间复杂度是 O(logn)，我们循环执行了 n 遍，时间复杂度就是 O(nlogn)了。

  O(nlogn) 是一种非常常见的时间复杂度，归并排序，快速排序的时间复杂度都是 O(nlogn)

* O(m + n), O(m * n)
  
  代码的复杂度由两个数据规模来决定。

  ```
  func test(m, n int) int {
      sum_1 := 0
      i := 1
      for ; i < m; i++ {
          sum_1 = sum_1 + i
      }

      sum_2 := 0
      j := 1
      for ; j < n; j++ {
          sum_2 = sum_2 + j
      }

      return sum_1 + sum_2
  }

  m 和 n 是表示两个数据规模，我们无法事先评估m 和 n 谁的量级大，所以不能简单的加法原则 省略掉其中的一个，

  因此，上面代码的时间复杂度为 O(m + n)

  乘法原则继续有效， T1(m)*T2(n) = O(f(m)*f(n))
  ```

### 最好，最坏，平均，均摊时间复杂度
1. 最好情况时间复杂度
2. 最坏情况时间复杂度
3. 平均情况时间复杂度
4. 均摊情况时间复杂度

#### 最好，最坏情况时间复杂度

```
func find(arr []int, n, x int) int {
    i := 0
    pos := -1
    for ; i < n; i++ {
        if arr[i] == x{
            pos = i
        }
    }
    return pos
}

其实我们在数组中查找一个数据，并不需要每次都把整个数组遍历一遍，因为有可能中途就可以找到。

如果数组中第一个元素正好是要查找的变量 x，那就不需要继续遍历剩下的 n-1 个数据了，此时的时间复杂度就是 O(1), 

如果数组中不存在变量 x ，那就需要把整个数组都遍历一遍，时间复杂度就成了 O(n)。
```

最好情况时间复杂度和最坏情况时间复杂度对应的都是机端情况下的代码复杂度，发生的概率其实并不大。为了更好的表示平均情况下了复杂度，我们需要引入平均情况时间复杂度

大多数情况下，我们并不需要区分最好，最坏，平均情况复杂度。

#### 均摊时间复杂度

```
arr := make([]int, n)
count := 0

func insert(val int) {
    if count == len(arr) {
        sum := 0
        for i := 0; i < len(arr); i++ {
            sum = sum + arr[i]
        }
        arr[0] = sum
        count = 1
    }
    arr[count] = val
    count++
}
```

最好情况时间复杂度、最坏情况时间复杂度、平均情况时间复杂度、均摊时间复杂度

同一段代码，在不同输入的情况下，复杂度量级有可能是不一样的


## 数组


