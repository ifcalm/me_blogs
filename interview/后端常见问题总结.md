## 操作系统篇

### 进程

**进程是指计算机已运行的程序**，在面向进程设计的系统（早期的 linux2.4 以及更早版本中）, 进程是程序的基本执行实体，在面向线程设计的系统（Linux2.6 及以后的版本中）, **进程本身不是基本运行单位，而是线程的容器**

程序本身只是指令，数据及其组织形式的描述，相当于一个名词，进程才是程序的真正运行实例，是现在进行时

若干进程有可能与同一个程序相关系，且每个进程皆可以**同步或异步**的方式独立运行

现代计算机系统可在同一段时间内以进程的形式将多个程序加载到存储器中，并借由时间共享（或称时分复用），以在一个处理器上表现出同时（平行性）运行的感觉。同样的，使用多线程技术的操作系统或计算机体系结构，同样程序的平行线程，可在多CPU主机或网络上真正同时运行（**在不同的CPU上**）


**用户下达运行程序的命令后，就会产生进程**。同一程序可产生多个进程（一对多关系），以允许同时有多位用户运行同一程序，却不会相冲突

进程需要一些资源才能完成工作，如CPU使用时间、存储器、文件以及I/O设备，且为依序逐一进行，**也就是每个CPU任何时间内仅能运行一项进程**

进程与线程的区别：**进程是计算机管理运行程序的一种方式，一个进程下可包含一个或者多个线程。线程可以理解为子进程**

#### 进程的状态
- 新生
- 运行
- 等待
- 就绪
- 结束


### 线程

**线程是操作系统能够进行运算调度的最小单位**，大部分情况下，它被包含在进程之中，是进程中的实际运行单位

一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务

**线程是独立调度和分配的基本单位**

**同一进程中的多条线程将共享该进程中的全部系统资源**

### 调度

调度，是将任务分配至资源的过程，在计算机或生产处理中尤为重要

### 函数调用创建栈

调用栈最经常被用于存放子程序的返回地址。在调用任何子程序时，主程序都必须暂存子程序运行完毕后应该返回到的地址。因此，如果被调用的子程序还要调用其他的子程序，其自身的返回地址就必须存入调用栈，在其自身运行完毕后再行取回。在递归程序中，每一层次递归都必须在调用栈上增加一条地址，因此如果程序出现无限递归（或仅仅是过多的递归层次），调用栈就会产生栈溢出


### 堆栈溢出

是指使用过多的存储器时导致调用堆栈产生的溢出，也是**缓冲区溢出**中的一种。堆栈溢出的产生是由于过多的函数调用，导致使用的调用堆栈大小超过事先规划的大小，覆盖其他存储器内的资料，一般在递归中产生。堆栈溢出很可能由无限递归产生，但也可能仅仅是过多的堆栈层级

**无限递归是堆栈溢出的最常见原因**

### 缓存区溢出

向程序输入缓冲区写入使之溢出的内容（通常是超过缓冲区能保存的最大数据量的数据），从而破坏程序运行、趁著中断之际并获取程序乃至系统的控制权

缓冲区溢出指当某个数据超过了处理程序回传堆栈地址限制的范围时，程序出现的异常操作

### CPU分时共享系统

- 时间片: 是把计算机的系统资源（尤其是CPU时间）进行时间上的分割，每个时间段称为一个时间片，每个用户依次轮流使用时间片
- 分时技术: 把处理机的运行时间分为很短的时间片，按时间片轮流把处理机分给各联机作业使用
- 设计目标: 对用户的请求及时响应，并在可能条件下尽量提高系统资源的利用率



### 5.进程和线程的生命周期

### 6.进程中的多线程

### 7.线程安全

线程安全就是多线程访问时，采用了**加锁机制**，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。 不会出现数据不一致或者数据污染。 线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据

**指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成**

假设有间银行只有 1000 元，而两个人同时提领 1000 元时就可能会拿到总计 2000 元的金额。为了避免这个问题，该间银行提款时应该使用互斥锁，即意味着针对同一个资源处理时，前一个人提领交易完成后才处理下一笔交易。但这种手法会使得效能降低

### 互斥锁

互斥锁是一种用于多线程编程中，防止两条线程同时对同一公共资源（比如全局变量）进行读写的机制

### 临界区域

在同步的程序设计中，临界区段指的是一个访问共享资源的**程序片段**，而这些共享资源又无法同时被多个线程访问的特性

当有线程进入临界区段时，其他线程或是行程必须等待，有一些同步的机制必须在临界区段的进入点与离开点实现，以确保这些共享资源是被异或的使用

### 8.临界区加锁

### 9.高并发-->响应变慢-->分布式系统架构

高并发通常是指，通过设计保证系统能够同时并行处理很多请求


### 并发与并行

- 并发: 有处理多个任务的能力，不一定同时（CPU 轮询）
- 并行: 有同时处理多个任务的能力（多个CPU 同时执行任务）


### 10.锁是如何实现的，如何保证自己是线程安全的

### 11.内存管理



### 12.文件系统

### 13.分布式文件系统

### 14.进程间的并发，同步，通信

### 垃圾回收

---------------------------

## 数据结构篇

### 1.数组

### 2.链表（重要）

### 3.Hash 表

### 4.栈

### 5.队列

### 6.树

### 7.Hash表数组长度不足怎么办

### 8.如何使Hash表中的数据分布更加均匀

### 9.写一个一致性Hash算法的实现

### 10.多线程并发修改Hash表怎么办？如何保证线程安全？

### 一致性 Hash算法

----------------

### java虚拟机原理（JVM）

### JVM的垃圾回收

### 内存溢出和内存泄漏有什么区别

-------------------------

## 网络通信篇

### IP协议

### IP地址

### DNS协议

### CDN--内容分发网络

### HTTP协议

### TCP协议

### socket网络编程

### TCP 三次握手

### LB--负载均衡

### RPC远程调用

### 分布式缓存集群

### 搜索引擎集群

--------------------------

## 数据库篇

### 关系型数据库原理

### 索引

### 数据库文件存储原理


--------------------------

## 编程语言篇

### 面向机器编程

### 面向过程编程

### 面向对象编程

### 函数式编程

### 函数作为值传递的意义

### 不同的编程语言在不同的应用场景中，各有自己的优势和劣势，你觉得哪些编程语言更适合用在哪些地方，适合处理哪些问题？

---------------------------

## 软件设计篇（软件建模）

### UML 建模

### 如何进行软件架构设计

### 设计原则与设计模式

### 软件设计的开闭原则

### 策略模式

### 适配器模式

### 观察者模式

### 模板方法模式

### 依赖倒置原则

### 软件分层设计

### 里氏替换原则

### 单一职责原则

### 接口隔离原则

### 封装

### 继承

### 多态(多态)

### 设计模式的应用

### 异步编程

### 高内聚低耦合

### 设计模式的应用场景

--------------------------

## 架构篇

### 分布式架构

### 面对同样的高并发用户的访问请求压力

### 分布式缓存

### 负载均衡

### 反向代理

### CDN

### 分布式消息队列

### 分布式数据库

### NoSQL 数据库

### 分布式文件

### 微服务

### 搜索引擎


### 缓存架构

### 异步加购

### 消息队列的异步架构

### 同步与异步

### 发布订阅模式

### 负载均衡架构

### DNS 负载均衡

### 反向代理负载均衡

### IP 负载均衡

### 数据链路层负载均衡

### 负载均衡算法

### 数据存储架构

### 数据库主从复制

### 数据库分片

### NoSQL 数据库

### CAP原理


### 高性能架构

### 性能指标

### 性能测试

### 性能优化

### 高可用架构

### 安全性架构

### 数据加解密

### HTTP 攻击与防护

### 大数据架构



--------------------------

Q: 为什么有些数据结构的内存空间不要求是连续的？都是连续的内存空间不好吗。既然连续和不连续的内存空间都可以实现这些数据结构，使用不连续的内存空间实现有什么好处呢，利用率更高吗。为什么利用率更高呢，不都是以字节为基本单位吗

A: 程序运行过程中，内存不断被申请、释放，内存的空闲空间呈碎片化，本身就是不连续的

Q: 负载均衡就是将不同的网络请求数据分发到多台服务器上，每台服务器承担一部分请求负载压力，多台服务器共同承担外部并发请求的压力，负载均衡实现方案你了解哪些呢？

在软件设计开发这个领域，好的设计和坏的设计最大的差别就体现在应对需求变更的能力上。

**数据的搜索与查找技术是计算机软件的核心算法**


-----------------------------------------

### Debug 方法



